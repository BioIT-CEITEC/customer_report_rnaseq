---
output:
  bookdown::html_document2:
    highlight: tango
    number_sections: false
    global_numbering: true
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true

params:
  config: snakemake.params.config
  set_author: snakemake.params.author
  set_email: snakemake.params.email
---

---
title: RNA-Seq and DE analysis
author:
  - Bioinformatics Core Facility, Centre for Molecular Medicine, CEITEC Masaryk University
  - ^1^CEITEC-Central European Institute of Technology, Masaryk University, Kamenice 5, 625 00 Brno, Czech Republic
  - `r params$set_author`^1^ [`r params$set_email`](mailto:`r params$set_email`)
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

```{r load-packages, include=FALSE}
library(data.table)
library(jsonlite)
library(flextable)
library(stringr)
library(ggplot2)
library(TidyMultiqc)
library(tidyr)
library(officer)
library(plotly)

knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
set_flextable_defaults(font.family = "Arial", font.size = 12, padding.top = 3, padding.bottom = 3)
```

```{r variables, results='asis', echo=FALSE}
config_json <- as.data.table(fromJSON(txt = params$config))
config_json[,condition := sapply(1:length(config_json$samples),function(x) config_json$samples[[x]]$condition)]
config_json[,replicate := sapply(1:length(config_json$samples),function(x) config_json$samples[[x]]$replicate)]
config_json[,full_name := sapply(1:length(config_json$samples),function(x) config_json$samples[[x]]$sample_name)]

comparison <- unlist(strsplit(unique(config_json$comparison),split="\\|"))
biotype <- unlist(strsplit(unique(config_json$biotype_list),split="\\|"))
analysis_type <- unlist(strsplit(unique(config_json$analysis_type),split="\\|"))
DE <- paste0("DE_",analysis_type) # feature_count is usually run by default
analysis_type <- gsub("feature_count","featureCount",analysis_type)
analysis_type <- gsub("kallisto","Kallisto",analysis_type)
analysis_type <- gsub("salmon_aln","Salmon (alignment mode)",analysis_type)
analysis_type <- gsub("salmon_map","Salmon (mapping mode)",analysis_type)

`%!in%` <- Negate(`%in%`)
`%!like%` <- Negate(`%like%`)

mRNA_DE_FOLDER_PATH <- paste0("../results/",DE,"/")
INPUTFILES <- paste0("../qc_reports/")
MQC_DATA <- paste0(INPUTFILES,"all_samples/","multiqc_data/")

# set of colors for plot to look like multiqc
highchart.v4 <- c("#7cb5ec", "#434348", "#90ed7d", "#f7a35c", "#8085e9", "#f15c80", "#e4d354", "#2b908f", "#f45b5b", "#91e8e1")
rseqc.palette <- c("#7cb5ec","#434348","#90ed7d","#f7a35c","#8085e9","#f15c80","#e4d354","#2b908f","#f45b5b","#91e8e1","#cccccc","#7f0000")
biobloom.palette <- c("#7cb5ec","#434348","#90ed7d","#f7a35c","#8085e9","#f15c80","#e4d354","#2b908f","#f45b5b","#91e8e1","#148E0B","#FDE74C","#7f0000","#cccccc")
star.palette <- c("#437bb1","#7cb5ec","#f7a35c","#e63491","#b1084c","#7f0000")

# biobloom ref table
biobloom_ref<-data.table(species=c("human","mouse","rat","budding yeast","fruit fly","dog","thale cress","rape","nematode"),
                         ref=c("human_38","mouse","rat","yeast","fruit_fly","dog","A.thaliana","brassica","C.elegans"))
biobloom_ref<-biobloom_ref[species==config_json$species[1],]

```

# Acknowledgement

- We request co-authorship (and will assist with manuscript preparation) if we have developed novel tools, algorithms, or pipelines, participated in experiment design planning, or have contributed to a biological question addressed in a manuscript. We ask that, at a minimum, you acknowledge us in a publication to which we have contributed routine analysis without further support and discussions, data management or conversion, or data submission services.
- Core Facility Bioinformatics of CEITEC Masaryk University is gratefully acknowledged for the obtaining of the scientific data presented in this paper.

# Description
```{r samples, results='asis', echo=FALSE}
species <- config_json$species[1]
reference <- config_json$reference[1]
num_samples <- length(config_json[,full_name])
num_conditions <- length(unique(config_json$condition))
num_replicat <- length(unique(config_json$replicate))
rna_type <- config_json$RNAseq_type[1]
if(config_json$strandness[1] == "fwd"){
  strandness <- "Forward"
}else if(config_json$strandness[1] == "rev"){
  strandness <- "Reverse"
}else if(config_json$strandness[1] == "unstr"){
  strandness <- "Unstranded"
}
umi <- config_json$UMI[1]

paired <- ifelse(config_json$is_paired[1] == TRUE, "paired-end", "single-end")

tabl_sample <- fread(paste0(MQC_DATA,"multiqc_trimmomatic.txt"), header=T)
tabl_sample[, Sample := gsub("_R.","",Sample)]
if(is.null(tabl_sample$input_reads)==T){tabl_sample[,input_reads:=input_read_pairs]}
tabl_sample <- merge(config_json[, .(Sample = full_name, condition)], tabl_sample, by="Sample")
setorder(tabl_sample, condition, Sample)

# Height for sample plots
# default is good for few samples and Read coverage plot
default_height <- 5
# custom is needed if several samples >= 40 ? -> 10
custom_height1 <- ifelse(num_samples < 40, default_height, 10)
# another custom if the first one is not enough (rRNA plot can need higher value because of pair-end doubling the amount of samples) -> 15
custom_height2 <- ifelse(paired == "paired-end" & num_samples >= 40, 15, custom_height1)
```
- The main goal of the experiment is to perform Differential Expression analysis.
- In general, we have `r num_samples` `r species` samples. We have `r num_conditions` conditions, those conditions are sequenced in `r num_replicat` replicates, which is sufficient to obtain statistical significance.
- Conditions to compare are:
`r border_remove(theme_booktabs(delete_part(qflextable(data = as.data.frame(unique(comparison))),part = "header")))`

`r if(rna_type == "classic_rev"){paste0("- Samples were sequenced using ",paired," 75 bp reads; NEBNext Ultra II Directional RNA Library Prep Kit for Illumina + polyA selection.")}`
`r if(rna_type == "quant_fwd"){"- Samples were sequenced using Lexogen Quantseq FWD kit, therefore a lot of reads in UTR regions are expected as well as huge 3’ sequencing bias. These data can only be used for differential expression analysis."}`
`r if(umi != "no_umi"){"- Samples contained 6bp long UMIs used for detection of PCR duplicates in library."}`

## Agreed task(s)
1. General samples QC.
2. RNA-Seq analysis.
3. DE analysis.

## Samples
- Brief sample description and number of raw and preprocessed reads are summarized in Table \@ref(tab:tabl-sample).

```{r tab.id="tabl-sample", tab.cap="Sample description - condition assignment and number of raw and preprocessed reads.",  results='asis', echo=FALSE, ft.split=F}
fit_to_width(autofit(qflextable(tabl_sample[, .(Sample, condition, "raw reads" = input_reads, "preprocessed reads" = surviving)])),max_width = 9.1)
```

## Analysis
- Raw reads were quality checked (**FastQC, MultiQC, minion, swan**), preprocessed (**Trimmomatic, FastQC, MultiQC**) and mapped (**STAR, Samtools, MultiQC**) to the reference genome with gene annotation (**genome version: `r reference`**).
- Mapped reads were counted and summarized to genes with:
`r if(config_json$feature_count[1] == TRUE){"  - **featureCounts**."}`
`r if(config_json$RSEM[1] == TRUE){"  - **RSEM**."}`
`r if(config_json$salmon_align[1] == TRUE){"  - **Salmon in alignment mode**."}`
`r if(config_json$salmon_map[1] == TRUE){"  - **Salmon in mapping mode**."}`
`r if(config_json$kallisto[1] == TRUE){"  - **Kallisto**."}`
  - Only uniquely mapped and uniquely assigned reads were counted.

- The library preparation kit strand-specificity is: **`r tolower(strandness)`**, and only reads in this strand should be considered.
`r if(config_json$display_fastq_screen_RNA[1] == TRUE | config_json$display_picard_RNA[1] == TRUE | config_json$display_RSeQC_RNA[1] == TRUE | config_json$display_biotypes_RNA[1] == TRUE | config_json$display_biobloom[1] == TRUE){"- Following checks were performed to estimate the overall sample quality:"}`
`r if(config_json$display_fastq_screen_RNA[1] == TRUE){"  - rRNA content estimate (**fastq_screen**)."}`
`r if(config_json$display_picard_RNA[1] == TRUE){"  - Read duplication rate (**dupRadar, Picard tools**)."}`
`r if(config_json$display_picard_RNA[1] == TRUE | config_json$display_RSeQC_RNA[1] == TRUE){"  - Sequenced (targeted) regions (**RSeQC, Picard tools**)."}`
`r if(config_json$display_picard_RNA[1] == TRUE){"  - 5’/3’ coverage bias (**Picard tools**)."}`
`r if(config_json$display_biotypes_RNA[1] == TRUE){"  - Expressed gene biotypes (**featureCounts**)."}`
`r if(config_json$display_RSeQC_RNA[1] == TRUE){"  - Library strandness (**RSeQC**)."}`
`r if(config_json$display_biobloom[1] == TRUE){"  - Contamination check (**Biobloom tools**)."}`
`r if(config_json$display_fastq_screen_RNA[1] == TRUE | config_json$display_picard_RNA[1] == TRUE | config_json$display_RSeQC_RNA[1] == TRUE | config_json$display_biotypes_RNA[1] == TRUE | config_json$display_biobloom[1] == TRUE){"- Other quality checks are available upon request."}`
- Complete settings, used commands, tool versions and methodology part for a publication can be provided upon request.

## Results
### General samples QC
- The sequencing depth varies from ~`r round(tabl_sample[input_reads == min(input_reads), input_reads]/1000000)`M of reads for sample `r tabl_sample[input_reads == min(input_reads), Sample]` to ~`r round(tabl_sample[input_reads == max(input_reads), input_reads]/1000000)`M of reads for sample `r tabl_sample[input_reads == max(input_reads), Sample]`.

```{r adaptors, results='asis', echo=FALSE}

if(file.exists(paste0(MQC_DATA,"mqc_fastqc_adapter_content_plot_1.txt"))){
 adaptor_max <- fread(paste0(MQC_DATA,"mqc_fastqc_adapter_content_plot_1.txt"), header=T)
 adaptor_max <- melt(adaptor_max, id.vars = c("Sample"), value.name = "plot.adaptor.max")
}else{
 #adaptor_max <- load_multiqc(paste0(MQC_DATA,"multiqc_data.json"), sections = c('plots'), plot_opts = list(fastqc_adapter_content_plot= list(extractor = extract_ignore_x, summary = list(max = max), prefix = "adaptor"))) # tidymultiqc v0.1.0
 adaptor_plot <- load_multiqc(paste0(MQC_DATA,"multiqc_data.json"), sections = 'plot', plots = 'fastqc_adapter_content_plot')
 if(length(adaptor_plot)>0){
    adaptor_max <- adaptor_plot %>% tidyr::unnest(cols = plot.fastqc_adapter_content_plot) %>%
         dplyr::group_by(metadata.sample_id) %>%
         dplyr::summarise(plot.adaptor.max = max(y))
 }else{
   adaptor_max <- NULL
 }
}

if("plot.adaptor.max" %in% colnames(adaptor_max) == TRUE){
 max_adaptor <- round(max(adaptor_max$plot.adaptor.max, na.rm = TRUE),0)
}else{
 max_adaptor <- 0.1 # in some cases multiqc is not reporting the plot if "No samples found with any adapter contamination > 0.1%"
}

```

- Initial quality check for analysis `r ifelse(max_adaptor < 1,"did not show","shows")` presence of adapters (~`r max_adaptor`%), `r ifelse(max_adaptor < 1,"no","")` adapter trimming was performed.
- Other initial quality checks look OK

### Alignment and splices
```{r star, results='asis', echo=FALSE}
multiqc_star <- fread(paste0(MQC_DATA,"multiqc_star.txt"))
multiqc_star <- multiqc_star[, Sample:=as.character(Sample)]
multiqc_star <- merge(config_json[, .(Sample = full_name, condition)], multiqc_star, by="Sample")

multiqc_star_tabl <- multiqc_star[, .(Sample, condition,
                                      total_reads = as.integer(total_reads),
                                      uniquely_mapped = as.integer(uniquely_mapped),
                                      multimapped = as.integer(multimapped),
                                      multimapped_toomany = as.integer(multimapped_toomany),
                                      unmapped_mismatches = as.integer(unmapped_mismatches),
                                      unmapped_tooshort = as.integer(unmapped_tooshort),
                                      unmapped_other = as.integer(unmapped_other))]
multiqc_star_tabl <- melt(multiqc_star_tabl, id.vars = c("Sample","condition","total_reads"))
multiqc_star_tabl <- multiqc_star_tabl[, percentage:=round(100*value/total_reads, 2), by="Sample"]
multiqc_star_tabl <- multiqc_star_tabl[, variable := factor(variable, levels = c("uniquely_mapped","multimapped",
                                                                                 "multimapped_toomany","unmapped_mismatches",
                                                                                 "unmapped_tooshort","unmapped_other"))]

tabl_mapread <- multiqc_star[, .(Sample, condition,
                                      uniquely_mapped, uniquely_mapped_percent,
                                      multimapped, multimapped_percent,
                                      mapped = uniquely_mapped+multimapped, mapped_percent = uniquely_mapped_percent + multimapped_percent)]
setorder(tabl_mapread, condition, Sample)

map.mean.perc <- round(mean(tabl_mapread[,mapped_percent]), 0)
uni.map.mean.perc <- round(mean(tabl_mapread[,uniquely_mapped_percent]), 0)
multi.map.mean.perc <- round(mean(tabl_mapread[,multimapped_percent]), 0)

if(map.mean.perc > 60){
  map.perc <- "very high"
}else if(map.mean.perc > 50 & map.mean.perc <= 60){
  map.perc <- "high"
}else if(map.mean.perc > 30 & map.mean.perc <= 50){
  map.perc <- "moderate"
}else if(map.mean.perc > 10 & map.mean.perc <= 30){
  map.perc <- "low"
}else if(map.mean.perc <= 10){
  map.perc <- "very low"
}

map.min <- min(round(tabl_mapread[,mapped]/1E6))
map.max <- max(round(tabl_mapread[,mapped]/1E6))

star.labcol <- multiqc_star_tabl[, .(variable = unique(variable) , Colour = star.palette, Label = c("Uniquely mapped", "Mapped to multiple loci",
                                                                                                    "Mapped to too many loci","Unmapped: too many missmatches",
                                                                                                    "Unmapped: too short","Unmapped: other"))]

# check and remove variable that have 0%
star.perc.not0 <- multiqc_star_tabl[, .(sum = sum(percentage)), by = variable][sum > 0,]$variable
multiqc_star_perc <- multiqc_star_tabl[variable %in% star.perc.not0,]
star.labcol.perc <- star.labcol[variable %in% star.perc.not0,]
# check and remove variable that have 0 counts
star.count.not0 <- multiqc_star_tabl[, .(sum = sum(value)), by = variable][sum > 0,]$variable
multiqc_star_count <- multiqc_star_tabl[variable %in% star.count.not0,]
star.labcol.count <- star.labcol[variable %in% star.count.not0,]

plot.multiqc_star_perc <- ggplot(multiqc_star_perc, aes(Sample, percentage, fill = variable)) +
  geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
  scale_fill_manual(values = star.labcol.perc$Colour, labels = star.labcol.perc$Label, name = "") +
  coord_flip() +
  scale_y_continuous(name = "Percentages", breaks = seq(0,100,10)) +
  xlab("") +
  scale_x_discrete(limits=rev) +
  theme_bw() +
  theme(legend.position="bottom") +
  theme(legend.key.size = unit(0.6,"line")) +
  guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
  theme(plot.title = element_text(face="bold")) +
  ggtitle("STAR: Alignment Scores")

plotly.multiqc_star_perc <- ggplotly(plot.multiqc_star_perc, tooltip="percentage") %>% layout(legend = list(orientation = 'h', y=-0.3))

for(i in 1:length(star.labcol.perc$variable)){
  plotly.multiqc_star_perc$x$data[[i]]$name <- star.labcol.perc$Label[i]
}

plot.multiqc_star_count <- ggplot(multiqc_star_count, aes(Sample, value, fill = variable)) +
  geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
  scale_fill_manual(values = star.labcol.count$Colour, labels = star.labcol.count$Label, name = "") +
  coord_flip() +
  xlab("") +
  ylab("Number of Reads") +
  scale_x_discrete(limits=rev) +
  theme_bw() +
  theme(legend.position="bottom") +
  theme(legend.key.size = unit(0.6,"line")) +
  guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
  theme(plot.title = element_text(face="bold")) +
  ggtitle("STAR: Alignment Scores")

plotly.multiqc_star_count <- ggplotly(plot.multiqc_star_count, tooltip="value") %>% layout(legend = list(orientation = 'h', y=-0.3))

for(i in 1:length(star.labcol.count$variable)){
  plotly.multiqc_star_count$x$data[[i]]$name <- star.labcol.count$Label[i]
}

```

- The `r paired` reads were aligned to `r species` reference genome with the help of the gene annotation (`r reference`) using STAR aligner.
- The percentage of uniquely- and multi-mapped reads are `r map.perc` for all samples (~`r map.mean.perc`% with ~`r uni.map.mean.perc`% of uniquely-mapped and ~`r multi.map.mean.perc`% of multi-mapped),
and the total number of mapped reads varies between ~`r map.min`M for `r tabl_mapread[mapped == min(mapped),]$Sample` and ~`r map.max`M for `r tabl_mapread[mapped == max(mapped),]$Sample` (Table \@ref(tab:tabl-mapread), Figure \@ref(fig:star-map-perc) & \@ref(fig:star-map-count)).

```{r tab.id="tabl-mapread", tab.cap="Number and percentage of uniquely- and multi-mapped reads", results='asis', echo=FALSE, out.width="80%", ft.split=F}
fit_to_width(autofit(qflextable(tabl_mapread[,.(Sample, condition, "uniquely mapped" = uniquely_mapped, "uniquely mapped (%)" = uniquely_mapped_percent, multimapped, "multimapped (%)" = multimapped_percent)])),max_width = 9.1)
```


#### STAR plots {.tabset}

##### Percentages
```{r star-map-perc, results='asis', echo=FALSE, fig.cap="Percentages and distribution of different mapping types. For more details please see the STAR aligner manual.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
plotly.multiqc_star_perc
```

##### Number of reads
```{r star-map-count, results='asis', echo=FALSE, fig.cap="Count and distribution of different mapping types. For more details please see the STAR aligner manual.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
plotly.multiqc_star_count
```

#### {-}

`r if(config_json$display_fastq_screen_RNA[1] == TRUE){paste0("### rRNA contamination")}`
```{r rrna, results='asis', echo=FALSE}
if(config_json$display_fastq_screen_RNA[1] == TRUE){
  fastq.screen.files <- fread(paste0(MQC_DATA,"multiqc_fastq_screen.txt"))
  #fastq.screen.files <- merge(config_json[, .(Sample = full_name, condition)], fastq.screen.files[, Sample := gsub("_screen$","",Sample)], by="Sample")
  fastq.screen.files <- fastq.screen.files[, Sample := gsub("_screen$","",Sample)]

  rrna <- fastq.screen.files[, .(Sample, rRNA.perc=get("rRNA percentage"))]

  rrna.p <- ggplot(rrna, aes(Sample, rRNA.perc)) +
    geom_bar(stat = "identity", width = 0.8, fill = "#7f0000") +
    theme_bw() +
    coord_flip() +
    ylab("rRNA content (%)") +
    xlab("") +
    scale_x_discrete(limits=rev) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("rRNA Content")

  plotly.rrna.p <- ggplotly(rrna.p, tooltip = "rRNA.perc") %>% layout(legend = list(orientation = 'h', y=-0.3))

  rrna.max <- round(max(rrna[,rRNA.perc]))
}

```

`r if(config_json$display_fastq_screen_RNA[1] == TRUE){paste0("- Samples had a percentage of rRNA contamination up to ",rrna.max,"%.")}`
`r if(config_json$display_fastq_screen_RNA[1] == TRUE){paste0("  - For polyA selection, we would expect ~ 1%, while for rRNA depletion it could be up to 10%.")}`
`r if(config_json$display_fastq_screen_RNA[1] == TRUE){paste0("  - A less effective polyA selection procedure can lead to a higher percentage of rRNA, but overall we still have a lot of usable reads and information to perform Differential expression analysis.")}`
`r if(config_json$display_fastq_screen_RNA[1] == TRUE){paste0("  - The percentages are summarized in Figure \\@ref(fig:fastq-screen-rrna).")}`

```{r fastq-screen-rrna, results='asis', echo=FALSE, fig.cap="rRNA estimate.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height2}
if(config_json$display_fastq_screen_RNA[1] == TRUE){plotly.rrna.p}
```

`r if(config_json$display_biobloom[1] == TRUE){"### Species contamination"}`

```{r biobloom-check, echo=FALSE}

if(config_json$display_biobloom[1] == TRUE){
  biobloom.files <- list.files(INPUTFILES, pattern = ".biobloom_summary.tsv", recursive = T, full.names = T)
  biobloomCounts <- fread(biobloom.files[1], header=T, stringsAsFactors = F)
  biobloomCounts[, `:=` (total = hits + misses, value = hits - shared, percentage = (hits - shared)/(hits + misses)), by = filter_id] # count total number of matches and species percentage (without shared)
  biobloomCounts[, Sample := gsub(".*/","",gsub(".biobloom_summary.tsv","",biobloom.files[1]))] # add column Sample

  if (length(biobloom.files) > 1) {
    for (i in 2:length(biobloom.files)){
      sample <- fread(biobloom.files[i], header=T, stringsAsFactors = F)
      sample[, `:=` (total = hits + misses, value = hits - shared, percentage = (hits - shared)/(hits + misses)), by = filter_id] # count total number of matches and species percentage (without shared)
      sample[, Sample := gsub(".*/","",gsub(".biobloom_summary.tsv","",biobloom.files[i]))] # add column Sample
      biobloomCounts <- rbind(biobloomCounts,sample)
    }
  }

  # extract species of interest average percentage
  biobloomCounts.species.mean <- round(mean(100*biobloomCounts[filter_id == biobloom_ref$ref,]$percentage,0))

  biobloom_plot <- load_multiqc(paste0(MQC_DATA,"multiqc_data.json"), sections = 'plot', plots = 'biobloom_tools') %>%
          tidyr::unnest(cols = plot.biobloom_tools)
  biobloom_plot <- as.data.table(biobloom_plot)
  setnames(biobloom_plot,"metadata.sample_id","Sample")
  biobloom_plot <- biobloom_plot[, Sample := gsub(".biobloom","", Sample)]
  biobloom_plot <- melt(biobloom_plot, id.vars = c("Sample"))
  biobloom_plot <- biobloom_plot[, variable := factor(variable,
                                     levels = c("human_38","mouse","yeast","fruit_fly","athaliana","celegans","multiple_genomes","no_match"),
                                     labels = c("human","mouse","yeast","fruit fly","A. thaliana","C. elegans","Multiple genomes","No match"))]
  biobloom_plot <- biobloom_plot[, total := sum(value), by=.(Sample)]
  biobloom_plot <- biobloom_plot[, percentage := round(100*value/total, 2)]

  plot.biobloom.pct <- ggplot(biobloom_plot, aes(Sample, percentage, fill = variable)) +
  geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
  scale_fill_manual(values = c(biobloom.palette[1:(length(levels(biobloom_plot$variable))-2)],biobloom.palette[13:14])) +
  coord_flip() +
  scale_y_continuous(name = "Percentages", breaks = seq(0,100,10)) +
  xlab("") +
  scale_x_discrete(limits=rev) +
  theme_bw() +
  theme(legend.position="bottom") +
  theme(legend.key.size = unit(0.6,"line")) +
  guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
  theme(plot.title = element_text(face="bold")) +
  ggtitle("BioBloom Tools: Alignment counts per species")

  plotly.biobloom.pct <- ggplotly(plot.biobloom.pct, tooltip = "percentage") %>% layout(legend = list(orientation = 'h', y=-0.3))

  plot.biobloom.count <- ggplot(biobloom_plot, aes(Sample, value, fill = variable)) +
  geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
  scale_fill_manual(values = c(biobloom.palette[1:(length(levels(biobloom_plot$variable))-2)],biobloom.palette[13:14])) +
  coord_flip() +
  ylab("Number of hits") +
  xlab("") +
  scale_x_discrete(limits=rev) +
  theme_bw() +
  theme(legend.position="bottom") +
  theme(legend.key.size = unit(0.6,"line")) +
  guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
  theme(plot.title = element_text(face="bold")) +
  ggtitle("BioBloom Tools: Alignment counts per species")

  plotly.biobloom.count <- ggplotly(plot.biobloom.count, tooltip = "value") %>% layout(legend = list(orientation = 'h', y=-0.3))

}

```

`r if(config_json$display_biobloom[1] == TRUE){"#### BioBloom Tools results {.tabset}"}`

`r if(config_json$display_biobloom[1] == TRUE){"- To check contamination we used basic model organisms eg. Mouse, Yeast, *D. Melanogaster*, *A. thaliana* and *C. elegans*"}`
`r if(config_json$display_biobloom[1] == TRUE){paste0("- All samples have about ",biobloomCounts.species.mean,"% of reads mapped only to ",config_json$species_name[1],", which is quite good and expected number")}`
`r if(config_json$display_biobloom[1] == TRUE){"- The different amount are summarized in Figure \\@ref(fig:biobloom-pct) & \\@ref(fig:biobloom-count)."}`

`r if(config_json$display_biobloom[1] == TRUE){"##### Percentages"}`

```{r biobloom-pct, results='asis', echo=FALSE, fig.cap="Species contamination (Percentage of hits).", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$display_biobloom[1] == TRUE){plotly.biobloom.pct}
```

`r if(config_json$display_biobloom[1] == TRUE){"##### Number of hits"}`

```{r biobloom-count, results='asis', echo=FALSE, fig.cap="Species contamination (Number of hits).", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$display_biobloom[1] == TRUE){plotly.biobloom.count}
```

`r if(config_json$display_biobloom[1] == TRUE){"#### {-}"}`

### Mapped regions
```{r rseqc-metrics, echo=FALSE}
if(config_json$display_RSeQC_RNA[1]==TRUE){
  rseqc.metric <- fread(paste0(MQC_DATA,"multiqc_rseqc_read_distribution.txt"))
  rseqc.metric <- merge(config_json[, .(Sample = full_name, condition)], rseqc.metric[, Sample:=gsub(".RSeQC.*","",Sample)], by="Sample")

  rseqc.count <- names(rseqc.metric)[names(rseqc.metric) %like% "tag_count"]
  rseqc.metric.tbl <- cbind(rseqc.metric[,.(Sample,total_tags)], rseqc.metric[, ..rseqc.count])
  #rseqc.metric.tbl <- rseqc.metric.tbl[, other_intergenic_tag_pct := 100-rowSums(.SD), .SDcols = 2:11]
  rseqc.metric.tbl <- rseqc.metric.tbl[, `:=` (true_tss_up_5kb_tag_count = tss_up_5kb_tag_count - tss_up_1kb_tag_count,
                                               true_tss_up_10kb_tag_count = tss_up_10kb_tag_count - tss_up_5kb_tag_count,
                                               true_tes_down_5kb_tag_count = tes_down_5kb_tag_count - tes_down_1kb_tag_count,
                                               true_tes_down_10kb_tag_count = tes_down_10kb_tag_count - tes_down_5kb_tag_count)]
  rseqc.metric.tbl <- rseqc.metric.tbl[, `:=` (tss_up_5kb_tag_count = NULL,
                                               tss_up_10kb_tag_count = NULL,
                                               tes_down_5kb_tag_count = NULL,
                                               tes_down_10kb_tag_count = NULL)]

  rseqc.metric.tbl <- rseqc.metric.tbl[, "mrna" := (get("cds_exons_tag_count") + get("5_utr_exons_tag_count") + get("3_utr_exons_tag_count")), by="Sample"]

  names(rseqc.metric.tbl) <- gsub("true_","",names(rseqc.metric.tbl))
  names(rseqc.metric.tbl) <- gsub("_tag_count","",names(rseqc.metric.tbl))
  rseqc.metric.tbl <- melt(rseqc.metric.tbl, id.vars = c("Sample","total_tags"))
  rseqc.metric.tbl <- rseqc.metric.tbl[, percentage:=round(100*value/total_tags,2), by="Sample"]

  rseqc.metric.tbl <- rseqc.metric.tbl[variable == "cds_exons", variable := "CDS_Exons"]
  rseqc.metric.tbl <- rseqc.metric.tbl[variable == "5_utr_exons", variable := "5'UTR_Exons"]
  rseqc.metric.tbl <- rseqc.metric.tbl[variable == "3_utr_exons", variable := "3'UTR_Exons"]
  rseqc.metric.tbl <- rseqc.metric.tbl[variable == "introns", variable := "Introns"]
  rseqc.metric.tbl <- rseqc.metric.tbl[variable == "tss_up_1kb", variable := "TSS_up_1kb"]
  rseqc.metric.tbl <- rseqc.metric.tbl[variable == "tss_up_5kb", variable := "TSS_up_5kb"]
  rseqc.metric.tbl <- rseqc.metric.tbl[variable == "tss_up_10kb", variable := "TSS_up_10kb"]
  rseqc.metric.tbl <- rseqc.metric.tbl[variable == "tes_down_1kb", variable := "TES_down_1kb"]
  rseqc.metric.tbl <- rseqc.metric.tbl[variable == "tes_down_5kb", variable := "TES_down_5kb"]
  rseqc.metric.tbl <- rseqc.metric.tbl[variable == "tes_down_10kb", variable := "TES_down_10kb"]
  rseqc.metric.tbl <- rseqc.metric.tbl[variable == "other_intergenic", variable := "Other_intergenic"]
  rseqc.metric.tbl <- rseqc.metric.tbl[,variable := factor(variable, levels = c("CDS_Exons","5'UTR_Exons","3'UTR_Exons","Introns","TSS_up_1kb","TSS_up_5kb","TSS_up_10kb","TES_down_1kb","TES_down_5kb","TES_down_10kb","Other_intergenic","mrna"))]

  plot.rseqc.metric.pct <- ggplot(rseqc.metric.tbl[variable!="mrna"], aes(Sample, percentage, fill = variable)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = rseqc.palette, labels = c("CDS_Exons","5'UTR_Exons","3'UTR_Exons","Introns","TSS_up_1kb","TSS_up_5kb","TSS_up_10kb","TES_down_1kb","TES_down_5kb","TES_down_10kb","Other_intergenic"), name = "") +
    coord_flip() +
    scale_y_continuous(name = "Percentages", breaks = seq(0,100,10)) +
    xlab("") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("RSeQC: Read Distribution")

  plotly.rseqc.metric.pct <- ggplotly(plot.rseqc.metric.pct, tooltip = "percentage") %>% layout(legend = list(orientation = 'h', y=-0.3))

  plot.rseqc.metric.count <- ggplot(rseqc.metric.tbl[variable!="mrna"], aes(Sample, value, fill = variable)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = rseqc.palette, labels = c("CDS_Exons","5'UTR_Exons","3'UTR_Exons","Introns","TSS_up_1kb","TSS_up_5kb","TSS_up_10kb","TES_down_1kb","TES_down_5kb","TES_down_10kb","Other_intergenic"), name = "") +
    coord_flip() +
    xlab("") +
    ylab("# Tags") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("RSeQC: Read Distribution")

  plotly.rseqc.metric.count <- ggplotly(plot.rseqc.metric.count, tooltip = "value") %>% layout(legend = list(orientation = 'h', y=-0.3))

  rseqc.intron <- rseqc.metric.tbl[variable=="Introns", .(intron=round(mean(percentage),0))]
  rseqc.mrna <- rseqc.metric.tbl[variable=="mrna", .(mrna=round(mean(percentage),0))]

  if(rseqc.intron$intron >= 40){
    intron.count <- "very high"
  }else if(rseqc.intron$intron >= 20 & rseqc.intron$intron < 40){
    intron.count <- "high"
  }else if(rseqc.intron$intron >= 10 & rseqc.intron$intron < 20){
    intron.count <- "moderate"
  }else if(rseqc.intron$intron >= 5 & rseqc.intron$intron < 10){
    intron.count <- "low"
  }else if(rseqc.intron$intron < 5){
    intron.count <- "very low"
  }

  if(rseqc.mrna$mrna > 70){
    coding.count <- "very high"
  }else if(rseqc.mrna$mrna > 60 & rseqc.mrna$mrna <= 70){
    coding.count <- "high"
  }else if(rseqc.mrna$mrna > 40 & rseqc.mrna$mrna <= 60){
    coding.count <- "moderate"
  }else if(rseqc.mrna$mrna > 20 & rseqc.mrna$mrna <= 40){
    coding.count <- "low"
  }else if(rseqc.mrna$mrna <= 20){
    coding.count <- "very low"
  }

}
```


```{r picard-metrics, echo=FALSE}
if(config_json$display_picard_RNA[1]==TRUE){
  picard.metric <- fread(paste0(MQC_DATA,"multiqc_picard_RnaSeqMetrics.txt"))
  picard.metric <- picard.metric[,Sample:=as.character(Sample)]
  picard.metric <- merge(config_json[, .(Sample = full_name, condition)], picard.metric, by="Sample")

  picard.metric.tbl <- picard.metric[, .(Sample, PF_BASES, PF_ALIGNED_BASES, Coding = CODING_BASES, UTR = UTR_BASES, Intronic = INTRONIC_BASES, Intergenic = INTERGENIC_BASES, not_aligned = PF_NOT_ALIGNED_BASES)]
  picard.metric.tbl <- picard.metric.tbl[, "mrna" := (Coding + UTR), by="Sample"]
  picard.metric.tbl <- melt(picard.metric.tbl, id.vars = c("Sample","PF_BASES","PF_ALIGNED_BASES"))
  picard.metric.tbl <- picard.metric.tbl[, percentage := round(100*value/PF_BASES,2), by="Sample"]
  picard.metric.tbl <- picard.metric.tbl[variable!="not_aligned", pct_aligned := round(100*value/PF_ALIGNED_BASES,2), by="Sample"]
  picard.metric.tbl <- picard.metric.tbl[, variable := factor(variable, levels = c("Coding","UTR","Intronic","Intergenic","not_aligned","mrna"))]

  plot.picard.metric.count <- ggplot(picard.metric.tbl[variable!="mrna",], aes(Sample, value, fill = variable)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = rseqc.palette, labels = c("Coding","UTR","Intronic","Intergenic","PF not aligned"), name = "") +
    coord_flip() +
    xlab("") +
    ylab("Number of reads") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=1, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("Picard: RnaSeqMetrics Read Assignments")

  plotly.picard.metric.count <- ggplotly(plot.picard.metric.count, tooltip = "value") %>% layout(legend = list(orientation = 'h', y=-0.3))

  plot.picard.metric.perc <- ggplot(picard.metric.tbl[variable!="mrna",], aes(Sample, percentage, fill = variable)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = rseqc.palette, labels = c("Coding","UTR","Intronic","Intergenic","PF not aligned"), name = "") +
    coord_flip() +
    scale_y_continuous(name = "Percentages (over all bases)", breaks = seq(0,100,10)) +
    xlab("") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=1, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("Picard: RnaSeqMetrics Read Assignments")

  plotly.picard.metric.perc <- ggplotly(plot.picard.metric.perc, tooltip = "percentage") %>% layout(legend = list(orientation = 'h', y=-0.3))

  plot.picard.metric.perc.align <- ggplot(picard.metric.tbl[variable!="mrna" & variable!="not_aligned",], aes(Sample, pct_aligned, fill = variable)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = rseqc.palette, labels = c("Coding","UTR","Intronic","Intergenic"), name = "") +
    coord_flip() +
    scale_y_continuous(name = "Percentages (over aligned bases)", breaks = seq(0,100,10)) +
    xlab("") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=1, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("Picard: RnaSeqMetrics Read Assignments")

  plotly.picard.metric.perc.align <- ggplotly(plot.picard.metric.perc.align, tooltip = "pct_aligned") %>% layout(legend = list(orientation = 'h', y=-0.3))

  picard.intron <- picard.metric.tbl[variable=="Intronic", .(intron=round(mean(percentage),0))]
  picard.intron.aligned <- picard.metric.tbl[variable=="Intronic", .(intron=round(mean(pct_aligned),0))]
  picard.mrna <- picard.metric.tbl[variable=="mrna", .(mrna=round(mean(percentage),0))]
  picard.mrna.aligned <- picard.metric.tbl[variable=="mrna", .(mrna=round(mean(pct_aligned),0))]

  if(config_json$display_RSeQC_RNA[1]==FALSE){
    if(picard.intron$intron >= 40){
      intron.count <- "very high"
    }else if(picard.intron$intron >= 20 & picard.intron$intron < 40){
      intron.count <- "high"
    }else if(picard.intron$intron >= 10 & picard.intron$intron < 20){
      intron.count <- "moderate"
    }else if(picard.intron$intron >= 5 & picard.intron$intron < 10){
      intron.count <- "low"
    }else if(picard.intron$intron < 5){
      intron.count <- "very low"
    }

    if(picard.mrna$mrna > 70){
      coding.count <- "very high"
    }else if(picard.mrna$mrna > 60 & picard.mrna$mrna <= 70){
      coding.count <- "high"
    }else if(picard.mrna$mrna > 40 & picard.mrna$mrna <= 60){
      coding.count <- "moderate"
    }else if(picard.mrna$mrna > 20 & picard.mrna$mrna <= 40){
      coding.count <- "low"
    }else if(picard.mrna$mrna <= 20){
      coding.count <- "very low"
    }
  }

}
```

```{r intron-expectation, echo=FALSE}
if(config_json$display_RSeQC_RNA[1]==TRUE | config_json$display_picard_RNA[1]==TRUE){
  if(config_json$type_of_extraction[1]=="PolyA" & coding.count %in% c("low","very low")){
    coding.expect<-"unexpected"
  }else if(config_json$type_of_extraction[1]=="PolyA" & coding.count %in% c("moderate","high","very high")){
    coding.expect<-"expected"
  }else if(config_json$type_of_extraction[1]=="rRNA" & coding.count %in% c("low","very low")){
    coding.expect<-"unexpected"
  }else if(config_json$type_of_extraction[1]=="rRNA" & coding.count %in% c("moderate","high","very high")){
    coding.expect<-"expected"
  }
}
```


`r if(config_json$display_RSeQC_RNA[1]==TRUE | config_json$display_picard_RNA[1]==TRUE){"- Evaluation of the mapped genomic regions is very comparable"}`
`r if(config_json$display_RSeQC_RNA[1]==TRUE | config_json$display_picard_RNA[1]==TRUE){paste0("- All samples had a ",intron.count," content of intronic reads")}`
`r if(config_json$display_picard_RNA[1]==TRUE){paste0("  - About ",picard.intron.aligned$intron,"% counted over aligned bases.")}`
`r if(config_json$display_RSeQC_RNA[1]==TRUE){paste0("  - About ",rseqc.intron$intron,"% counted over reads.")}`
`r if(config_json$display_RSeQC_RNA[1]==TRUE | config_json$display_picard_RNA[1]==TRUE){paste0("- All samples had a ",coding.count," content of mapped reads within coding regions, which is ",coding.expect," for ",config_json$type_of_extraction[1]," selection library protocols.")}`
`r if(config_json$display_picard_RNA[1]==TRUE){paste0("  - About ",picard.mrna.aligned$mrna,"% counted over bases (Figures \\@ref(fig:picard-map-loc-pct-align) & \\@ref(fig:picard-map-loc-pct) & \\@ref(fig:picard-map-loc-count)).")}`
`r if(config_json$display_RSeQC_RNA[1]==TRUE){paste0("  - About ",rseqc.mrna$mrna,"% counted over reads (Figures \\@ref(fig:rseqc-map-loc-pct) & \\@ref(fig:rseqc-map-loc-count)).")}`

`r if(config_json$display_picard_RNA[1]==TRUE){paste0("#### Picard metrics {.tabset}")}`

`r if(config_json$display_picard_RNA[1]==TRUE){paste0("##### Percentages (over aligned bases)")}`
```{r picard-map-loc-pct-align, results='asis', echo=FALSE, fig.cap="Mapped locations (Picard; in bases).", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$display_picard_RNA[1]==TRUE){plotly.picard.metric.perc.align}

```

`r if(config_json$display_picard_RNA[1]==TRUE){paste0("##### Percentages (over all bases)")}`
```{r picard-map-loc-pct, results='asis', echo=FALSE, fig.cap="Mapped locations (Picard; in bases).", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$display_picard_RNA[1]==TRUE){plotly.picard.metric.perc}
```

`r if(config_json$display_picard_RNA[1]==TRUE){paste0("##### Counts")}`
```{r picard-map-loc-count, results='asis', echo=FALSE, fig.cap="Mapped locations (Picard; in bases).", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$display_picard_RNA[1]==TRUE){plotly.picard.metric.count}
```

`r if(config_json$display_picard_RNA[1]==TRUE){paste0("#### {-}")}`

`r if(config_json$display_RSeQC_RNA[1]==TRUE){paste0("#### RSeQC metrics {.tabset}")}`

`r if(config_json$display_RSeQC_RNA[1]==TRUE){paste0("##### Percentages")}`
```{r rseqc-map-loc-pct, results='asis', echo=FALSE, fig.cap="Mapped locations (RSeQC; in reads).", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$display_RSeQC_RNA[1]==TRUE){plotly.rseqc.metric.pct}
```

`r if(config_json$display_RSeQC_RNA[1]==TRUE){paste0("##### Number of Tags")}`
```{r rseqc-map-loc-count, results='asis', echo=FALSE, fig.cap="Mapped locations (RSeQC; in reads).", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$display_RSeQC_RNA[1]==TRUE){plotly.rseqc.metric.count}
```

`r if(config_json$display_RSeQC_RNA[1]==TRUE){paste0("#### {-}")}`



`r if(config_json$display_picard_RNA[1]==TRUE){"### Read coverage distribution"}`
`r if(config_json$display_picard_RNA[1]==TRUE){"- The gene body coverage is very similar in all the samples."}`
`r if(config_json$display_picard_RNA[1]==TRUE){if(rna_type == "classic_rev"){"  - Coverage across the gene is very even and shows very good coverage across whole genes "}else if(rna_type == "quant_fwd"){"  - Coverage across the gene is very good and shows the characteristic accumulation in 3'end of the genes in all the samples, which is typical from the library preparation using QuantSeq "}}`
`r if(config_json$display_picard_RNA[1]==TRUE){paste0("(Figure \\@ref(fig:picard-cov)).")}`

```{r picard-cov, results='asis', echo=FALSE, fig.cap="Gene body mapping distribution.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = default_height}
if(config_json$display_picard_RNA[1]==TRUE){
  # gene_cov <- load_multiqc(
  #   paste0(MQC_DATA,"multiqc_data.json"),
  #   sections = "plots",
  #   plot_opts = list(picard_rna_coverage = list(
  #     extractor = extract_xy,
  #     summary = list(
  #       df=list
  #     )
  #   ))
  # )
  gene_cov<-load_multiqc(paste0(MQC_DATA,"multiqc_data.json"), sections = 'plot', plots = 'picard_rna_coverage')
  # gene_cov <- as.data.table(gene_cov %>% unnest(plot.picard_rna_coverage.df))
  gene_cov <- as.data.table(gene_cov %>% unnest(plot.picard_rna_coverage))
  setnames(gene_cov, "metadata.sample_id","Sample")

  gene_cov <- merge(config_json[, .(Sample = full_name)], gene_cov, by="Sample")
  gene_cov <- gene_cov[, Sample := as.factor(Sample)]

  coul <- c(rseqc.palette,rseqc.palette)
  if(length(unique(gene_cov$Sample)) > length(coul)){
    coul <- colorRampPalette(coul)(length(unique(gene_cov$Sample)))
  }

  plot.gene.cov <- ggplot(gene_cov, aes(x, y, colour = Sample)) +
    geom_line() +
    scale_colour_manual(values = coul, name = "") +
    ylab("Coverage") +
    scale_x_continuous(name = "Percent through gene", breaks = seq(0,100,10)) +
    theme_bw() +
    theme(legend.position="none") +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("Picard: Normalized Gene Coverage")

  plotly.gene.cov <- ggplotly(plot.gene.cov) %>% layout(legend = list(orientation = 'h', y=-0.3))

  plotly.gene.cov
}
```


`r if(config_json$display_RSeQC_RNA[1]==TRUE){"### Strand specificity"}`
```{r rseqc-strand, echo=FALSE}
if(config_json$display_RSeQC_RNA[1]==TRUE){
  rseqc.infer.exp <- fread(paste0(MQC_DATA,"multiqc_rseqc_infer_experiment.txt"))
  rseqc.infer.exp <- rseqc.infer.exp[,Sample := gsub(".RSeQC.*","",Sample)]
  rseqc.infer.exp <- merge(config_json[, .(Sample = full_name, condition)], rseqc.infer.exp, by="Sample")
  setorder(rseqc.infer.exp, condition, Sample)

  rseqc.infer.exp <- melt(rseqc.infer.exp, id.vars = c("Sample","condition"))
  rseqc.infer.exp <- rseqc.infer.exp[, value := 100*value]
  rseqc.infer.exp <- rseqc.infer.exp[variable %like% "e_sense", variable:="Sense"]
  rseqc.infer.exp <- rseqc.infer.exp[variable %like% "e_antisense", variable:="Antisense"]
  rseqc.infer.exp <- rseqc.infer.exp[variable == "failed", variable:="Undetermined"]
  rseqc.infer.exp <- rseqc.infer.exp[, variable := factor(variable, levels = c("Sense", "Antisense", "Undetermined"))]

  rseqc.strand.spec <- rseqc.infer.exp[, .(mean = round(mean(value),0)), by="variable"]

  if(rseqc.strand.spec[variable == "Antisense", mean] >= 70){strandness.found <- "Reverse"}
  if(rseqc.strand.spec[variable == "Antisense", mean] < 30){strandness.found <- "Forward"}
  if(rseqc.strand.spec[variable == "Antisense", mean] >= 30 & rseqc.strand.spec[variable == "Antisense", mean] < 70){strandness.found <- "Unstranded"}

  plot.rseqc.infer.exp <- ggplot(rseqc.infer.exp, aes(Sample, value, fill = variable)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = rseqc.palette, labels = c("Sense", "Antisense", "Undetermined"), name = "") +
    coord_flip() +
    #scale_y_continuous(labels = scales::percent, name = "% Tags", breaks = c(0,0.2,0.4,0.6,0.8,1)) +
    scale_y_continuous(name = "% Tags", breaks = seq(0,100,10)) +
    xlab("") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("RSeQC: Infer experiment")

  plotly.rseqc.infer.exp <- ggplotly(plot.rseqc.infer.exp, tooltip = "value") %>% layout(legend = list(orientation = 'h', y=-0.3))
}
```

`r if(config_json$display_RSeQC_RNA[1]==TRUE){paste0("- According to the preparation kit reads should be ",if(strandness == 'Forward'){'in the forward strand.'}else if(strandness == 'Reverse'){'in the reverse strand.'}else if(strandness == 'Unstranded'){'unstranded.'})}`
`r if(config_json$display_RSeQC_RNA[1]==TRUE){paste0("- The analysis shows the strand-specificity of each library, but cannot be trusted with full confidence.")}`
`r if(config_json$display_RSeQC_RNA[1]==TRUE){paste0("  - All the samples have ~",rseqc.strand.spec[variable == 'Sense',]$mean,"% of the forward-strand specificity, ~",rseqc.strand.spec[variable == 'Antisense',]$mean,"% of the reverse-strand specificity but ~",rseqc.strand.spec[variable == 'Undetermined',]$mean,"% mappings cannot be determined.")}`
`r if(config_json$display_RSeQC_RNA[1]==TRUE){paste0("    - The latest are usually mappings to intergenic regions, unannotated regions or regions where two genes overlap at the same strand (Figure \\@ref(fig:rseqc-exp) ).")}`
`r if(config_json$display_RSeQC_RNA[1]==TRUE){paste0("  - We consider mapping as ",tolower(strandness.found)," as we got the highest number of suitable reads for DE analysis.")}`

```{r rseqc-exp, results='asis', echo=FALSE, fig.cap="Library strand specificity.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$display_RSeQC_RNA[1]==TRUE){plotly.rseqc.infer.exp}
```

`r if(config_json$RSEM[1] == TRUE | config_json$feature_count[1] == TRUE | config_json$salmon_align[1] == TRUE | config_json$salmon_map[1] == TRUE | config_json$kallisto[1] == TRUE){"### Read count assignment to genes"}`
```{r map-assign, echo=FALSE}
if(config_json$RSEM[1] == TRUE){
  rsem.assign <- fread(paste0(MQC_DATA,"multiqc_rsem.txt"))
  rsem.assign <- melt(rsem.assign[,.(Sample,Total,Unique,Multi,Filtered,Unalignable)], id.vars = c("Sample","Total"))
  rsem.assign <- rsem.assign[,percentage := round(100*value/Total, 2), by = "Sample"]

  rsem.assign <- rsem.assign[, label := variable]
  levels(rsem.assign$label) <- c("Aligned uniquely to a gene","Aligned to multiple genes","Filtered due to too many alignments","Unalignable reads")

  plot.rsem.assign.count <- ggplot(rsem.assign, aes(Sample, value, fill = label)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = star.palette[c(1,4,5,6)], name = "") +
    coord_flip() +
    ylab("# Reads") +
    xlab("") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=2, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("RSEM: Mapped reads")

  plotly.rsem.assign.count <- ggplotly(plot.rsem.assign.count, tooltip="value") %>% layout(legend = list(orientation = 'h', y=-0.3))

  plot.rsem.assign.pct <- ggplot(rsem.assign, aes(Sample, percentage, fill = label)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = star.palette[c(1,4,5,6)], name = "") +
    coord_flip() +
    scale_y_continuous(name = "Percentages", breaks = seq(0,100,10)) +
    xlab("") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=2, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("RSEM: Mapped reads")

  plotly.rsem.assign.pct <- ggplotly(plot.rsem.assign.pct, tooltip="percentage") %>% layout(legend = list(orientation = 'h', y=-0.3))

  rsem.alignable<-rsem.assign[variable=="Unique" | variable=="Multi", .(variable = "Alignable", value = sum(value), percentage = round(100*sum(value)/Total, 2)), by = .(Sample, Total)]

  rsem.assign.min <- round(min(rsem.alignable[, value]/1E6),0)
  rsem.assign.max <- round(max(rsem.alignable[, value]/1E6),0)
  rsem.assign.min.perc <- round(min(rsem.alignable[, percentage]),0)
  rsem.assign.max.perc <- round(max(rsem.alignable[, percentage]),0)
  rsem.assign.mean.perc <- round(mean(rsem.alignable[, percentage]),2)

  if(rsem.assign.mean.perc > 60){
    rsem.assign.perc <- "very high"
  }else if(rsem.assign.mean.perc > 50 & rsem.assign.mean.perc <= 60){
    rsem.assign.perc <- "high"
  }else if(rsem.assign.mean.perc > 30 & rsem.assign.mean.perc <= 50){
    rsem.assign.perc <- "moderate"
  }else if(rsem.assign.mean.perc > 10 & rsem.assign.mean.perc <= 30){
    rsem.assign.perc <- "low"
  }else if(rsem.assign.mean.perc <= 10){
    rsem.assign.perc <- "very low"
  }

}

if(config_json$feature_count[1] == TRUE){
  fc.assign <- fread(paste0(MQC_DATA,"multiqc_featureCounts.txt"))
  fc.assign <- fc.assign[,Sample:=as.character(Sample)]
  fc.assign <- merge(config_json[, .(Sample = full_name, condition)], fc.assign, by="Sample")
  setorder(fc.assign, condition, Sample)

  fc.assign <- melt(fc.assign[, percent_assigned:=NULL], id.vars = c("Sample","condition","Total"))
  fc.assign <- fc.assign[, percentage := round(100*value/Total, 2), by = "Sample"]

  fc.assign.min <- round(min(fc.assign[variable=="Assigned",value]/1E6),0)
  fc.assign.max <- round(max(fc.assign[variable=="Assigned",value]/1E6),0)
  fc.assign.min.perc <- round(min(fc.assign[variable=="Assigned",percentage]),0)
  fc.assign.max.perc <- round(max(fc.assign[variable=="Assigned",percentage]),0)
  fc.assign.mean.perc <- round(mean(fc.assign[variable=="Assigned",percentage]),2)

  if(fc.assign.mean.perc > 60){
    fc.assign.perc <- "very high"
  }else if(fc.assign.mean.perc > 50 & fc.assign.mean.perc <= 60){
    fc.assign.perc <- "high"
  }else if(fc.assign.mean.perc > 30 & fc.assign.mean.perc <= 50){
    fc.assign.perc <- "moderate"
  }else if(fc.assign.mean.perc > 10 & fc.assign.mean.perc <= 30){
    fc.assign.perc <- "low"
  }else if(fc.assign.mean.perc <= 10){
    fc.assign.perc <- "very low"
  }

  fc.assign <- fc.assign[, label := variable]
  levels(fc.assign$label) <- gsub("Unassigned_","Unassigned: ",levels(fc.assign$variable))
  levels(fc.assign$label) <- gsub("([a-z])([A-Z])","\\1 \\2",levels(fc.assign$label))
  levels(fc.assign$label) <- gsub("_"," ",levels(fc.assign$label))

  fc.name.not0 <- fc.assign[, .(sum = sum(value)), by = variable][sum > 0,]$variable
  fc.assign <- fc.assign[variable %in% fc.name.not0,]

  plot.fc.assign.count <- ggplot(fc.assign, aes(Sample, value, fill = label)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = biobloom.palette, name = "") +
    coord_flip() +
    xlab("") +
    ylab("# Reads") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("featureCounts: Assignments")

  plotly.fc.assign.count <- ggplotly(plot.fc.assign.count, tooltip = "value") %>% layout(legend = list(orientation = 'h', y=-0.3))

  plot.fc.assign.pct <- ggplot(fc.assign, aes(Sample, percentage, fill = label)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = biobloom.palette, name = "") +
    coord_flip() +
    xlab("") +
    scale_y_continuous(name = "Percentages", breaks = seq(0,100,10)) +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("featureCounts: Assignments")

  plotly.fc.assign.pct <- ggplotly(plot.fc.assign.pct, tooltip = "percentage") %>% layout(legend = list(orientation = 'h', y=-0.3))

  fc.reassign <- fc.assign[variable=="Assigned" | variable=="Unassigned_Unmapped",.(Sample,label,value)][unique(multiqc_star_tabl[,.(Sample,total_reads)]), on = .(Sample=Sample)]
  fc.reassign <- rbind(fc.reassign,fc.reassign[, .(label="No Features",value=total_reads-sum(value)), by=.(Sample,total_reads)])
  fc.reassign[,percentage:=round(100*value/total_reads,2)]

  plot.fc.reassign.pct <- ggplot(fc.reassign, aes(Sample, percentage, fill = label)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = biobloom.palette, name = "") +
    coord_flip() +
    xlab("") +
    scale_y_continuous(name = "Percentages", breaks = seq(0,100,10)) +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("featureCounts: Assignments (counted over reads)")

  plotly.fc.reassign.pct <- ggplotly(plot.fc.reassign.pct, tooltip = "percentage") %>% layout(legend = list(orientation = 'h', y=-0.3))

}

if(config_json$salmon_map[1] == TRUE){
  salmonM.files <- list.files(path=INPUTFILES, pattern = "_map.tsv", full.names = T, recursive = T)
  salmonM.assign <- fread(salmonM.files[1], header=T, stringsAsFactors = F)
  if (length(salmonM.files) > 1) {
    for (i in 2:length(salmonM.files)){
      sample <- fread(salmonM.files[i], header=T, stringsAsFactors = F)
      salmonM.assign <- rbind(salmonM.assign,sample)
    }
  }
  salmonM.assign[, Sample := gsub("_map$","",Samples)]
  salmonM.assign <- merge(config_json[, .(Sample = full_name, condition)], salmonM.assign, by="Sample")
  setorder(salmonM.assign, condition, Sample)

  salmonM.assign <- salmonM.assign[, Total := mapped+unmapped, by=.(Sample)]
  salmonM.assign <- melt(salmonM.assign, id.vars = c("Sample","condition","Samples","Total"))
  salmonM.assign <- salmonM.assign[, percentage := round(100*value/Total, 2), by = "Sample"]
  salmonM.assign <- salmonM.assign[, label:=variable]
  levels(salmonM.assign$label) <- c("Mapped","Unmapped")

  plot.salmonM.assign.count <- ggplot(salmonM.assign, aes(Sample, value, fill = label)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = star.palette[c(1,5)], name = "") +
    coord_flip() +
    xlab("") +
    ylab("# Reads") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("Salmon - mapping mode: Alignment Scores")

  plotly.salmonM.assign.count <- ggplotly(plot.salmonM.assign.count, tooltip = "value") %>% layout(legend = list(orientation = 'h', y=-0.3))

  plot.salmonM.assign.pct <- ggplot(salmonM.assign, aes(Sample, percentage, fill = label)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = star.palette[c(1,5)], name = "") +
    coord_flip() +
    xlab("") +
    scale_y_continuous(name = "Percentages", breaks = seq(0,100,10)) +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("Salmon - mapping mode: Alignment Scores")

  plotly.salmonM.assign.pct <- ggplotly(plot.salmonM.assign.pct, tooltip = "percentage") %>% layout(legend = list(orientation = 'h', y=-0.3))

}

if(config_json$salmon_align[1] == TRUE){
  salmonA.files <- list.files(path=INPUTFILES, pattern = "_aln.tsv", full.names = T, recursive = T)
  salmonA.assign <- fread(salmonA.files[1], header=T, stringsAsFactors = F)
  if (length(salmonA.files) > 1) {
    for (i in 2:length(salmonA.files)){
      sample <- fread(salmonA.files[i], header=T, stringsAsFactors = F)
      salmonA.assign <- rbind(salmonA.assign,sample)
    }
  }
  salmonA.assign[, Sample := gsub("_aln$","",Samples)]
  salmonA.assign <- merge(config_json[, .(Sample = full_name, condition)], salmonA.assign, by="Sample")
  setorder(salmonA.assign, condition, Sample)

  salmonA.assign <- salmonA.assign[, Total := mapped+unmapped, by=.(Sample)]
  salmonA.assign <- melt(salmonA.assign, id.vars = c("Sample","condition","Samples","Total"))
  salmonA.assign <- salmonA.assign[, percentage := round(100*value/Total, 2), by = "Sample"]
  salmonA.assign <- salmonA.assign[, label:=variable]
  levels(salmonA.assign$label) <- c("Mapped","Unmapped")

  plot.salmonA.assign.count <- ggplot(salmonA.assign, aes(Sample, value, fill = label)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = star.palette[c(1,5)], name = "") +
    coord_flip() +
    xlab("") +
    ylab("# Reads") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("Salmon - alignment mode: Alignment Scores")

  plotly.salmonA.assign.count <- ggplotly(plot.salmonA.assign.count, tooltip = "value") %>% layout(legend = list(orientation = 'h', y=-0.3))

  plot.salmonA.assign.pct <- ggplot(salmonA.assign, aes(Sample, percentage, fill = label)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = star.palette[c(1,5)], name = "") +
    coord_flip() +
    xlab("") +
    scale_y_continuous(name = "Percentages", breaks = seq(0,100,10)) +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("Salmon - alignment mode: Alignment Scores")

  plotly.salmonA.assign.pct <- ggplotly(plot.salmonA.assign.pct, tooltip = "percentage") %>% layout(legend = list(orientation = 'h', y=-0.3))
}

if(config_json$kallisto[1] == TRUE){
  kallisto.assign <- fread(paste0(MQC_DATA,"multiqc_kallisto.txt"))
  kallisto.assign <- kallisto.assign[, Sample := gsub("_R1$","",Sample)]
  kallisto.assign <- merge(config_json[, .(Sample = full_name, condition)], kallisto.assign, by="Sample")
  setorder(kallisto.assign, condition, Sample)

  kallisto.assign <- melt(kallisto.assign[, `:=` (percent_aligned=NULL,fragment_length=NULL)], id.vars = c("Sample","condition","total_reads"))
  kallisto.assign <- kallisto.assign[, percentage := round(100*value/total_reads, 2), by = "Sample"]
  kallisto.assign <- kallisto.assign[, label:=variable]
  levels(kallisto.assign$label) <- c("Pseudoaligned","Not aligned")

  plot.kallisto.assign.count <- ggplot(kallisto.assign, aes(Sample, value, fill = label)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = star.palette[c(1,5)], name = "") +
    coord_flip() +
    xlab("") +
    ylab("# Reads") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("Kallisto: Alignment Scores")

  plotly.kallisto.assign.count <- ggplotly(plot.kallisto.assign.count, tooltip = "value") %>% layout(legend = list(orientation = 'h', y=-0.3))

  plot.kallisto.assign.pct <- ggplot(kallisto.assign, aes(Sample, percentage, fill = label)) +
    geom_bar(stat = "identity" , width = 0.8, position = position_stack(reverse = TRUE)) +
    scale_fill_manual(values = star.palette[c(1,5)], name = "") +
    coord_flip() +
    xlab("") +
    scale_y_continuous(name = "Percentages", breaks = seq(0,100,10)) +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(legend.position="bottom") +
    theme(legend.key.size = unit(0.6,"line")) +
    guides(fill=guide_legend(nrow=3, byrow=TRUE)) +
    theme(plot.title = element_text(face="bold")) +
    ggtitle("Kallisto: Alignment Scores")

  plotly.kallisto.assign.pct <- ggplotly(plot.kallisto.assign.pct, tooltip = "percentage") %>% layout(legend = list(orientation = 'h', y=-0.3))
}

```


`r if(config_json$feature_count[1] == TRUE){paste0("#### Assignment featureCounts {.tabset}")}`

`r if(config_json$feature_count[1] == TRUE){paste0("- Read count assignment from **featureCounts** for RNA-Seq is ",fc.assign.perc," (between ",fc.assign.min.perc,"% and ",fc.assign.max.perc,"%, calculated only from uniquely mapped reads).")}`
`r if(config_json$feature_count[1] == TRUE){paste0("  - Number of assigned reads is above limits of the recommended number of reads (~",fc.assign.min,"-",fc.assign.max,"M).")}`
`r if(config_json$feature_count[1] == TRUE){paste0("  - Read assignment rates are summarized in Table \\@ref(tab:fc-assign-tab) and Figures \\@ref(fig:plotly-fc-assign-pct) to \\@ref(fig:plotly-fc-assign-count).")}`

```{r tab.id="fc-assign-tab", tab.cap="Summary of read-to-gene assignment. Percentages counted only from uniquely mapped reads - featureCounts.", results='asis', echo=FALSE, ft.split=F}
if(config_json$feature_count[1] == TRUE){
  fit_to_width(autofit(qflextable(fc.assign[variable=="Assigned",.(Sample, "Assigned"=value, "Assigned (%)"=percentage)])),max_width = 9.1)
}
```

`r if(config_json$feature_count[1] == TRUE){paste0("##### Percentages (counted over mapping)")}`
```{r plotly-fc-assign-pct, results='asis', echo=FALSE, fig.cap="featureCounts: Assignments.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$feature_count[1] == TRUE){plotly.fc.assign.pct}
```

`r if(config_json$feature_count[1] == TRUE){paste0("##### Percentages (counted over reads)")}`
```{r plotly-fc-reassign-pct, results='asis', echo=FALSE, fig.cap="featureCounts: Assignments. Percentage have been recomputed over reads.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$feature_count[1] == TRUE){plotly.fc.reassign.pct}
```

`r if(config_json$feature_count[1] == TRUE){paste0("##### Number of Reads")}`
```{r plotly-fc-assign-count, results='asis', echo=FALSE, fig.cap="featureCounts: Assignments.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$feature_count[1] == TRUE){plotly.fc.assign.count}
```

`r if(config_json$feature_count[1] == TRUE){paste0("#### {-}")}`


`r if(config_json$RSEM[1] == TRUE){paste0("#### Assignment RSEM {.tabset}")}`

`r if(config_json$RSEM[1] == TRUE){paste0("- Read count assignment from **RSEM** for RNA-Seq is ",rsem.assign.perc," (between ",rsem.assign.min.perc," % and ",rsem.assign.max.perc,"%).")}`
`r if(config_json$RSEM[1] == TRUE){paste0("  - Number of recommended assigned reads is 25M, we have a number of reads varying between ~",rsem.assign.min,"M and ",rsem.assign.max,"M.")}`
`r if(config_json$RSEM[1] == TRUE){paste0("  - Read assignment rates are summarized in Table \\@ref(tab:rsem-assign-tab) and Figures \\@ref(fig:plotly-rsem-assign-pct) & \\@ref(fig:plotly-rsem-assign-count).")}`

```{r tab.id="rsem-assign-tab", tab.cap="Summary of read-to-gene assignment. Percentages counted only from uniquely mapped reads - RSEM.", results='asis', echo=FALSE, ft.split=F}
if(config_json$RSEM[1] == TRUE){
fit_to_width(autofit(qflextable(rsem.alignable[,.(Sample, "Alignable"=value, "Alignable (%)"=percentage)])),max_width = 9.1)
}
```

`r if(config_json$RSEM[1] == TRUE){paste0("##### Percentages")}`
```{r plotly-rsem-assign-pct, results='asis', echo=FALSE, fig.cap="RSEM: Assignments.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$RSEM[1] == TRUE){plotly.rsem.assign.pct}
```

`r if(config_json$RSEM[1] == TRUE){paste0("##### Number of Reads")}`
```{r plotly-rsem-assign-count, results='asis', echo=FALSE, fig.cap="RSEM: Assignments.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$RSEM[1] == TRUE){plotly.rsem.assign.count}
```

`r if(config_json$RSEM[1] == TRUE){paste0("#### {-}")}`


`r if(config_json$salmon_align[1] == TRUE){paste0("#### Assignment Salmon - alignment mode {.tabset}")}`

`r if(config_json$salmon_align[1] == TRUE){paste0("  - Read assignment from Salmon in alignment mode are summarized in Table \\@ref(tab:salmonA-assign-tab) and Figures \\@ref(fig:plotly-salmonA-assign-pct) & \\@ref(fig:plotly-salmonA-assign-count).")}`

```{r tab.id="salmonA-assign-tab", tab.cap="Summary of read-to-gene assignment. Percentages counted only from uniquely mapped reads - Salmon (alignment mode)", results='asis', echo=FALSE, ft.split=F}
if(config_json$salmon_align[1] == TRUE){
fit_to_width(autofit(qflextable(salmonA.assign[variable=="mapped",.(Sample, "Aligned"=value, "Aligned (%)"=percentage)])),max_width = 9.1)
}
```

`r if(config_json$salmon_align[1] == TRUE){paste0("##### Percentages")}`
```{r plotly-salmonA-assign-pct, results='asis', echo=FALSE, fig.cap="Salmon (alignment mode): Assignments.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$salmon_align[1] == TRUE){plotly.salmonA.assign.pct}
```

`r if(config_json$salmon_align[1] == TRUE){paste0("##### Number of Reads")}`
```{r plotly-salmonA-assign-count, results='asis', echo=FALSE, fig.cap="Salmon (alignment mode): Assignments.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$salmon_align[1] == TRUE){plotly.salmonA.assign.count}
```

`r if(config_json$salmon_align[1] == TRUE){paste0("#### {-}")}`


`r if(config_json$salmon_map[1] == TRUE){paste0("#### Assignment Salmon - mapping mode {.tabset}")}`

`r if(config_json$salmon_map[1] == TRUE){paste0("  - Read assignment from Salmon in mapping mode are summarized in Table \\@ref(tab:salmonM-assign-tab) and Figures \\@ref(fig:plotly-salmonM-assign-pct) & \\@ref(fig:plotly-salmonM-assign-count).")}`

```{r tab.id="salmonM-assign-tab", tab.cap="Summary of read-to-gene assignment. Percentages counted only from uniquely mapped reads - Salmon (mapping mode)", results='asis', echo=FALSE, ft.split=F}
if(config_json$salmon_map[1] == TRUE){
fit_to_width(autofit(qflextable(salmonM.assign[variable=="mapped",.(Sample, "Aligned"=value, "Aligned (%)"=percentage)])),max_width = 9.1)
}
```

`r if(config_json$salmon_map[1] == TRUE){paste0("##### Percentages")}`
```{r plotly-salmonM-assign-pct, results='asis', echo=FALSE, fig.cap="Salmon (mapping mode): Assignments.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$salmon_map[1] == TRUE){plotly.salmonM.assign.pct}
```

`r if(config_json$salmon_map[1] == TRUE){paste0("##### Number of Reads")}`
```{r plotly-salmonM-assign-count, results='asis', echo=FALSE, fig.cap="Salmon (mapping mode): Assignments.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$salmon_map[1] == TRUE){plotly.salmonM.assign.count}
```

`r if(config_json$salmon_map[1] == TRUE){paste0("#### {-}")}`


`r if(config_json$kallisto[1] == TRUE){paste0("#### Assignment Kallisto {.tabset}")}`

`r if(config_json$kallisto[1] == TRUE){paste0("  - Read assignment from Kallisto are summarized in Table \\@ref(tab:kallisto-assign-tab) and Figures \\@ref(fig:plotly-kallisto-assign-pct) & \\@ref(fig:plotly-kallisto-assign-count).")}`

```{r tab.id="kallisto-assign-tab", tab.cap="Summary of read-to-gene assignment. Percentages counted only from uniquely mapped reads - Kallisto.", results='asis', echo=FALSE, ft.split=F}
if(config_json$kallisto[1] == TRUE){
fit_to_width(autofit(qflextable(kallisto.assign[variable=="pseudoaligned_reads",.(Sample, "Aligned"=value, "Aligned (%)"=percentage)])),max_width = 9.1)
}
```

`r if(config_json$kallisto[1] == TRUE){paste0("##### Percentages")}`
```{r plotly-kallisto-assign-pct, results='asis', echo=FALSE, fig.cap="Kallisto: Assignments.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$kallisto[1] == TRUE){plotly.kallisto.assign.pct}
```

`r if(config_json$kallisto[1] == TRUE){paste0("##### Number of Reads")}`
```{r plotly-kallisto-assign-count, results='asis', echo=FALSE, fig.cap="Kallisto: Assignments.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$kallisto[1] == TRUE){plotly.kallisto.assign.count}
```

`r if(config_json$kallisto[1] == TRUE){paste0("#### {-}")}`

```{r biotype-count, fig.cap = "Captured gene biotypes.", echo=FALSE, out.width="90%", fig.width=7, fig.height = custom_height1, fig.align="center", fig.show="hold", dev="svg"}
if(config_json$display_biotypes_RNA[1] == TRUE){
  biotype.files <- list.files(paste0(INPUTFILES), pattern = ".biotype_counts.txt", recursive = T)
  featureCounts <- fread(paste0(INPUTFILES,biotype.files[1]), header=T, stringsAsFactors = F)
  if (length(biotype.files) > 1) {
    for (i in 2:length(biotype.files)){
      sample <- fread(paste0(INPUTFILES,biotype.files[i]), header=T, stringsAsFactors = F)
      featureCounts <- merge(featureCounts,sample,by = "Geneid")
    }
  }
  colnames(featureCounts)[-1]<-sapply(biotype.files,function(x) gsub(".biotype_counts.txt","",basename(x)))  # Rename columns - split after first "_"

  featureCounts <- melt(featureCounts, id.vars = "Geneid", variable.name = "Sample")
  featureCounts <- merge(config_json[, .(Sample = full_name)], featureCounts, by = "Sample")

  featureCounts[, percentage := round((100*value/sum(value)),2), by=Sample] # compute percentage
  featureCounts[, total := sum(value), by = Sample]
  pct <- featureCounts[percentage >=2 ,] # Get abundant features (>= 2%)

  mean.pct <- pct[,.(Mean = mean(percentage)), by=.(Geneid)]
  setorder(mean.pct,-Mean)
  mean.pct$Geneid <- factor(mean.pct$Geneid, levels=mean.pct$Geneid[order(-mean.pct$Mean)], ordered=F)
  max.lvl <- length(levels(mean.pct$Geneid))
  levels(mean.pct$Geneid)[1+max.lvl]<-"other"

  others <- pct[, .(Geneid = "other", value = total - sum(value), percentage = round(100-(sum(percentage)),2)), by = .(Sample, total)] # Other features - added together to one
  others <- others[, .(Geneid, Sample, value, percentage, total)]

  pct <- rbind(pct, others)
  setorder(pct, Sample, value, Geneid)
  pct$Geneid <- factor(pct$Geneid, levels=levels(mean.pct$Geneid), ordered=TRUE)

  ### Plot Pie plot only if one sample
  if(length(unique(pct$Sample)) >= 1){
    mybar.pct <- ggplot(data = pct, aes(x=Sample, y=percentage, fill=Geneid)) +
            geom_bar(stat="identity",position = position_stack(reverse = TRUE)) +
            scale_fill_manual(values = c(biobloom.palette[1:max.lvl],biobloom.palette[14]), name = "") +
            theme_bw() +
            coord_flip() +
            scale_y_continuous(name = "Percentages", breaks = seq(0,100,10)) +
            xlab("") +
            scale_x_discrete(limits=rev) +
            theme(plot.title = element_text(face="bold")) +
            ggtitle("Gene Biotypes") +
            theme(legend.position="bottom") +
            theme(legend.key.size = unit(0.6,"line")) +
            guides(fill=guide_legend(nrow=2,byrow=TRUE))

    plotly.mybar.pct <- ggplotly(mybar.pct, tooltip = "percentage") %>% layout(legend = list(orientation = 'h', y=-0.3))

    mybar.count <- ggplot(data = pct, aes(x=Sample, y=value, fill=Geneid)) +
            geom_bar(stat="identity",position = position_stack(reverse = TRUE)) +
            scale_fill_manual(values = c(biobloom.palette[1:max.lvl],biobloom.palette[14]), name = "") +
            theme_bw() +
            coord_flip() +
            ylab("Counts") +
            xlab("") +
            scale_x_discrete(limits=rev) +
            theme(plot.title = element_text(face="bold")) +
            ggtitle("Gene Biotypes") +
            theme(legend.position="bottom") +
            theme(legend.key.size = unit(0.6,"line")) +
            guides(fill=guide_legend(nrow=2,byrow=TRUE))

    plotly.mybar.count <- ggplotly(mybar.count, tooltip = "value") %>% layout(legend = list(orientation = 'h', y=-0.3))
  }
}

```

`r if(config_json$display_biotypes_RNA[1] == TRUE){"### Biotypes {.tabset}"}`
`r if(config_json$display_biotypes_RNA[1] == TRUE){"- All the samples captured mainly protein-coding genes (Figures \\@ref(fig:plotly-mybar-pct) & \\@ref(fig:plotly-mybar-count))."}`
`r if(config_json$display_biotypes_RNA[1] == TRUE){"  - This is expected from polyA selection based libraries."}`

`r if(config_json$display_biotypes_RNA[1] == TRUE){paste0("#### Percentages")}`
```{r plotly-mybar-pct, results='asis', echo=FALSE, fig.cap="Gene biotypes.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$display_biotypes_RNA[1] == TRUE){plotly.mybar.pct}
```

`r if(config_json$display_biotypes_RNA[1] == TRUE){paste0("#### Counts")}`
```{r plotly-mybar-count, results='asis', echo=FALSE, fig.cap="Gene biotypes.", fig.align="center", out.width="90%", fig.show="hold", dev="svg", fig.width=7, fig.height = custom_height1}
if(config_json$display_biotypes_RNA[1] == TRUE){plotly.mybar.count}
```

`r if(config_json$display_biotypes_RNA[1] == TRUE){paste0("### {-}")}`

# Notes and comments
- We strongly recommend confirming all the events manually in genome/alignment browsers such as IGV, Tablet or Savant.
  - All the alignments and references are provided.

## Visualization

### IGV
- Reference genomes and annotations for `r reference` are available to download on [Ensembl](https://www.ensembl.org/index.html) website.
- You can upload the provided aligned bam files with the reference in IGV for visualization.
- The IGV tutorial is available [here](http://software.broadinstitute.org/software/igv/userguide).
- All the index files (.bai, .fai, .idx) must be in the same folder as their "parent" files otherwise IGV wouldn't open them.

# DE analysis
- For the DE analysis we used gene counts from the following tool(s): `r paste(analysis_type, collapse=", ")`.

## Expression-based quality check

### Normalization {.tabset}

```{r de-norm-count, echo=FALSE, out.width="80%", results="asis", dev="svg"}

norm.plot<-function(analysis_type = analysis_type, DE = DE){
  output<-cat("- Read counts for coding genes (mostly protein-coding genes) distribution is depicted in the following Figure(s).","\n")
  output<-c(output,cat("- Post-normalization counts (~normalized expressions) can be controlled for unusual remaining differences in expression level between samples.","\n"))
  output<-c(output,cat("- If the normalized expression is not similar between samples, it might be needed to sub-sample or remove sample(s) with too high expression difference.","\n\n"))

  for(j in 1:length(analysis_type)){
    output<-c(output,cat("#### ",analysis_type[j],"\n"))

    if(config_json$conditions_to_compare[1] == "all"){
      ppnc.files <- list.files(path=paste0("../results/",DE[j],"/",comparison[1],"/all/"),pattern ="pre_post_norm_counts.svg", full.names = T)
    }else{
      ppnc.files <- list.files(path=paste0("../results/",DE[j],"/",comparison,"/all/"),pattern ="pre_post_norm_counts.svg", full.names = T)
    }

    for(i in 1:length(ppnc.files)){
      output<-c(output,cat("<div align='center'><figure style='width:80%'><img src=",ppnc.files[i]," /><figcaption>Number of reads assigned to coding genes for all the samples before normalization (raw counts) and after normalization (normalized counts).</figcaption></figure></div>"))
      output<-c(output,cat("\n\n"))
    }
  }
  output<-c(output,cat("\n\n"))
  return(output)
}

no_null<-norm.plot(analysis_type, DE)

```

### {-}

```{r de-plot-dt, echo=FALSE, results="asis"}
plot.dt <- function(analysis.type = analysis_type, comp.folder = comparison, path.prefix = "../results/", path.suffix = "/report_data/", pattern1 = "volcanoplot.+png", pattern2 = "volcanoplot.+png"){
  dt <- data.table(analysis.type=rep(analysis.type,length(comp.folder)))
  setorder(dt, analysis.type)
  dt <- dt[,DE:=paste0("DE_",analysis.type)]
  dt <- dt[, comp.folder:=rep(comp.folder,length(unique(analysis.type)))]
  dt <- dt[, path1:=list.files(paste0(path.prefix,DE,"/",comp.folder,path.suffix), pattern = pattern1, full.names = TRUE), by=.(DE,comp.folder)]
  dt <- dt[, path2:=list.files(paste0(path.prefix,DE,"/",comp.folder,path.suffix), pattern = pattern2, full.names = TRUE), by=.(DE,comp.folder)]
  dt <- dt[, path:=ifelse(is.na(path2) == FALSE,path2,path1)]
  return(dt)
}

```

### Sample clustering
- Clustering of the samples (based on genes expression) shows if all the samples cluster together by their condition.
  - This is depicted in PCA plot (left).
  - This is summarized in heatmap (right).


```{r de-pca, echo=FALSE, out.width="80%", results="asis", dev="svg"}
pca_heatmap.plot<-function(analysis_type = analysis_type, comparison = comparison){
  output<-cat("- Samples from different condition clustering together might indicate a reduce effect coming from the tested treatment which often leads to low differentially expressed gene identification.","\n\n")
  if (dir.exists(paste0("../",DE[1],"/all_condition_results"))) {
    output<-c(output,cat("#### Result over all condition {.tabset} \n"))
    for(j in 1:length(analysis_type)){
      output<-c(output,cat("##### ",analysis_type[j],"\n"))
      allpca.dt <- plot.dt(analysis.type = analysis_type, comp.folder = "all_condition_results",path.prefix = "../", path.suffix = "/report_data/", pattern1 = "sample_to_sample_PCA.svg", pattern2 = "sample_to_sample_PCA_batch.svg")
      allheatmap.dt <- plot.dt(analysis.type = analysis_type, comp.folder = "all_condition_results",path.prefix = "../", path.suffix = "/report_data/", pattern1 = "heatmaps_samples_log2.png", pattern2 = "heatmaps_samples_log_batch.png")
      all_pca <- allpca.dt[analysis_type == analysis_type[j],]$path
      all_heatmap <- allheatmap.dt[analysis_type == analysis_type[j],]$path
      output<-c(output,cat("<div align='center'><figure style='width:50%;float:left'><img src=",all_pca," />","\n"))
      output<-c(output,cat("<figcaption>PCA (first two components) visualization of all samples (DESeq2 VST normalization).</figcaption></figure>","\n"))
      output<-c(output,cat("<figure style='width:50%;float:right'><img src=",all_heatmap," />","\n"))
      output<-c(output,cat("<figcaption>Heatmap of samples clustered by gene expression (DESeq2 log2 normalization).</figcaption></figure>","\n"))
      output<-c(output,cat("</div>","\n\n"))
    }
  output <- c(output,cat("#### {-} \n\n"))
  }
  output <- c(output,cat("#### Results for each condition {.tabset} \n"))
  for(i in 1:length(comparison)){
    output<-cat("##### ",comparison[i]," {.tabset}","\n")
    pca.dt <- plot.dt(analysis.type = analysis_type, comp.folder = comparison, path.prefix = "../", path.suffix = "/detail_results/report_data/", pattern1 = "sample_to_sample_PCA.svg", pattern2 = "sample_to_sample_PCA_batch.svg")
    heatmap.dt <- plot.dt(analysis.type = analysis_type, comp.folder = comparison,path.prefix = "../", path.suffix = "/detail_results/report_data/", pattern1 = "heatmaps_samples_log2.png", pattern2 = "heatmaps_samples_log_batch.png")
    for(j in 1:length(analysis_type)){
      output<-c(output,cat("###### ",analysis_type[j]," \n"))
      single_pca <- pca.dt[analysis.type == analysis_type[j] & comparison == comparison[i],]$path
      single_heatmap <- heatmap.dt[analysis.type == analysis_type[j] & comparison == comparison[i],]$path
      output<-c(output,cat("<div align='center'><figure style='width:50%;float:left'><img src=",single_pca," />","\n"))
      output<-c(output,cat("<figcaption>PCA (first two components) visualization of all samples (DESeq2 VST normalization).</figcaption></figure>","\n"))
      output<-c(output,cat("<figure style='width:50%;float:right'><img src=",single_heatmap," />","\n"))
      output<-c(output,cat("<figcaption>Heatmap of samples clustered by gene expression (DESeq2 log2 normalization).</figcaption></figure>","\n"))
      output<-c(output,cat("</div>","\n\n"))
    }
  }
  return(output)
}

no_null<-pca_heatmap.plot(analysis_type, comparison)

```

#### {-}

## Differential expression results

- Please note that for visualization purposes we had to set a predefined cut-off value for some of the parameters (adj.p-value and logFC)

- In this section, we might provide several results as the number of compared conditions is variable between experiments
- Differential gene expression was calculated by two separate tools - edgeR and DESeq2
  - Both of the tools have different performances: edgeR is usually more sensitive and less specific, DESeq2 is usually more specific and less sensitive; edgeR is more suitable for fewer replicates (<12) as it is not as conservative as DESeq2
  - Generally, DESeq2 is more conservative than edgeR.
  - If your goal is an exploratory analysis with a low number of replicates and with low expressed genes, edgeR might be your choice.
  - If you need a selection of genes which are strongly differentially expressed and you want to remove as many false-positive results as possible for a price of some false-negative results, DESeq2 might be your choice.
  - If you want to perform some sort of prioritization, you might select an overlap between the two tools.
  - **Note for DESeq2**: By default, DESeq2 applies independent filtering which aims at removing genes which are potential outliers or show “strange” behavior (~large variance). Filtered genes are then marked by NA in either p-value or adj.p-value column. This filtering might be in some cases too strict and might cause a loss of interesting results. For this reason, we also make DESeq2 results without the independent filtering (DESeq2_noIndFilt). If you choose DESeq2 results, I recommend to start with filtered results but look at the end of the table at the filtered genes (genes with NA in p-value/adj.-value are at the bottom of the table). In case you see some interesting results there you might consider switching to the unfiltered results. In edgeR analysis, only genes with very low expression are excluded (1 read-per-million reads in at least 3 samples).
- The full description of a DE results is given after in the Output files section

- Number of DE genes with default cut-off values is summarized in the following [Table](#summary-table).
  - Please note this is only a tentative view on approximate differences between the conditions and not final results.
- [Volcano plot](#volcano-ma-link) visualization visualizes log2FC (x-axis) and adj.p-value (y-axis).
  - Colored dots highlight genes above the defined adj.p-value cut-off value, blue lines show defined log2FC cut-off value.
  - The Volcano plot presented here are from DESeq2 results.
- [MA plot](#volcano-ma-link) visualizes mean expression (x-axis) and log2FC (y-axis).
  - Colored dots highlight genes above the defined cut-off values (both adj.p-value and log2FC).
  - The MA plot presented here are from DESeq2 results.
- An example of maximum top 20 most DE genes (by adj.p-value) can be found in the [heatmap](#heatmap-link) below.
  - The selection of a maximum 20 genes is always based on compared conditions but visualizes expression values from all other conditions if applicable.


### <a name="summary-table"> </a> Summary table {.tabset}

```{r tab.id="tabl-de-de", echo=FALSE, results="asis", ft.split=F}
summary.table<-function(comparison=comparison, analysis_type = analysis_type, DE = DE){
  output<-cat("\n")
  for(i in 1:length(comparison)){

    tabl.de.de.all <- data.table()

    for(j in 1:length(DE)){
      de.tab.edger <- fread(paste0("../",DE[j],"/",comparison[i],"/edgeR/edgeR.tsv"),
                          sep  = "\t",header = T)
      de.tab.deseq <- fread(paste0("../results/",DE[j],"/",comparison[i],"/detail_results/full_DESeq2.tsv"),
                          sep  = "\t",header = T)
      #de.tab.deseq.noIndFilt <- fread(paste0("../results/",DE[j],"/",comparison[i],"/all/DESeq2_noIndFilt.tsv"),
      #                    sep  = "\t",header = T)

      de.tab.edger.upl <- dim(de.tab.edger[padj < 0.05 & log2FoldChange >= 1,])[1]
      de.tab.edger.dnl <- dim(de.tab.edger[padj < 0.05 & log2FoldChange <= -1,])[1]
      de.tab.edger.up <- dim(de.tab.edger[padj < 0.05 & log2FoldChange > 0,])[1]
      de.tab.edger.dn <- dim(de.tab.edger[padj < 0.05 & log2FoldChange < 0,])[1]

      de.tab.deseq.upl <- dim(de.tab.deseq[padj < 0.05 & log2FoldChange >= 1,])[1]
      de.tab.deseq.dnl <- dim(de.tab.deseq[padj < 0.05 & log2FoldChange <= -1,])[1]
      de.tab.deseq.up <- dim(de.tab.deseq[padj < 0.05 & log2FoldChange > 0,])[1]
      de.tab.deseq.dn <- dim(de.tab.deseq[padj < 0.05 & log2FoldChange < 0,])[1]

      de.tab.deseq.noIndFilt.upl <- dim(de.tab.deseq[no_filter_padj < 0.05 & no_filter_log2FoldChange >= 1,])[1]
      de.tab.deseq.noIndFilt.dnl <- dim(de.tab.deseq[no_filter_padj < 0.05 & no_filter_log2FoldChange <= -1,])[1]
      de.tab.deseq.noIndFilt.up <- dim(de.tab.deseq[no_filter_padj < 0.05 & no_filter_log2FoldChange > 0,])[1]
      de.tab.deseq.noIndFilt.dn <- dim(de.tab.deseq[no_filter_padj < 0.05 & no_filter_log2FoldChange < 0,])[1]

      tabl.de.de <- data.table(Analysis=c("DESeq2","DESeq2 noIndFilt","edgeR"),
                up_pval_logfc=c(de.tab.deseq.upl,de.tab.deseq.noIndFilt.upl,de.tab.edger.upl),
                down_pval_logfc=c(de.tab.deseq.dnl,de.tab.deseq.noIndFilt.dnl,de.tab.edger.dnl),
                up_pval=c(de.tab.deseq.up,de.tab.deseq.noIndFilt.up,de.tab.edger.up),
                down_pval=c(de.tab.deseq.dn,de.tab.deseq.noIndFilt.dn,de.tab.edger.dn))
      tabl.de.de <- tabl.de.de[,.(Tool = analysis_type[j], Comparison = comparison[i], Analysis, up_pval_logfc, down_pval_logfc, up_pval, down_pval)]

      tabl.de.de.all <- rbind(tabl.de.de.all,tabl.de.de)
    }

    #knitr::kable(x = tabl.de.de, booktabs = TRUE, caption = capt, format.args = list(big.mark = ","))
    edgeR.tag.pos <- which(tabl.de.de.all == "edgeR", arr.ind = TRUE) # find row and column with "edgeR"
    # change the table to a flextable object
    ftabl.de.de.all <- flextable(tabl.de.de.all[,.(Tool, Comparison, Analysis,
                                                   "Up (adj.pval & logfc)"=up_pval_logfc,
                                                   "Down (adj.pval & logfc)"=down_pval_logfc,
                                                   "Up (adj.pval)"=up_pval,
                                                   "Down (adj.pval)"=down_pval)])

    # apply conditional formating - for each row with "edgeR" add a horizontal line
    for(k in 1:nrow(edgeR.tag.pos)) {
      ftabl.de.de.all <- ftabl.de.de.all %>%
      hline(i = edgeR.tag.pos[k, 1], border = fp_border(color = "black", style = "solid", width = 1))
    }
    final.table<-fit_to_width(autofit(ftabl.de.de.all), max_width = 9.1)
    output<-c(output,cat("#### ",comparison[i],"\n"))
    output<-c(output,cat(flextable_to_rmd(final.table))) # transform the table object in rmd text which is properly recognized when knitted
    output<-c(output,cat("\n\n"))
  }
  output<-c(output,cat("\n\n"))
  return(output)
}

no_null<-summary.table(comparison, analysis_type, DE)

```

### {-}

Summary or number of DE genes based on default cut-off values from all three DE calculations. The first two columns are counts with both adj.p-value and logFC cut-off, the other two columns are only with adj.p-value cut-off. DESeq2 results, DESeq2 results without independent filtering (noIndFilt) and edgeR results are shown.

### Volcano & MA plots {.tabset}

<a name="volcano-ma-link"> </a>

```{r de-volcano-ma, echo=FALSE, out.width="80%", results="asis", dev="svg"}

volcano.ma.plots<-function(comparison=comparison, analysis_type = analysis_type, DE = DE){
  output<-cat("#### ",comparison[1]," {.tabset}","\n")
  for(j in 1:length(DE)){
    volcano.files <- grep(grep(grep(list.files(path=paste0("../",DE[j],"/",comparison[1],"/report_data/"),
                               pattern = "volcanoplot_", full.names = T), pattern="Filt", value = T, invert = T),
                               pattern="edgeR", value = T, invert = T), pattern=".png", value=T)
    ma.files <- grep(grep(grep(list.files(path=paste0("../",DE[j],"/",comparison[1],"/report_data/"),
                               pattern = "MAplot_", full.names = T), pattern="Filt", value = T, invert = T),
                               pattern="edgeR", value = T, invert = T), pattern=".png", value=T)

    output<-c(output,cat("##### ",analysis_type[j],"\n"))
    if(length(volcano.files)>=1){
      for(k in 1:length(volcano.files)){
        output<-c(output,cat("<div align='center'>","\n"))
        output<-c(output,cat("<figure><img src=",volcano.files[k]," width='80%'/>","\n"))
        output<-c(output,cat("<figcaption>Volcano plot (DESeq2 results with independent filtering on). Maximum of 20 most DE genes (by adj.p-value) are named.</figcaption></figure>","\n"))
        output<-c(output,cat("<figure><img src=",ma.files[k]," width='80%'/>","\n"))
        output<-c(output,cat("<figcaption>MA plot (DESeq2 results with independent filtering on). Maximum of 20 most DE genes (by adj.p-value) are named.</figcaption></figure>","\n"))
        output<-c(output,cat("</div>","\n\n"))
      }
    }
  }
  output<-c(output,cat("#### {-}","\n\n"))
  if(length(comparison)>1){
    for(i in 2:length(comparison)){
      output<-c(output,cat("#### ",comparison[i],"\n"))
      for(j in 1:length(DE)){
        volcano.files <- grep(grep(grep(list.files(path=paste0("../",DE[j],"/",comparison[i],"/report_data/"),
                               pattern = "volcanoplot_", full.names = T), pattern="Filt", value = T, invert = T),
                               pattern="edgeR", value = T, invert = T), pattern=".png", value=T)
        ma.files <- grep(grep(grep(list.files(path=paste0("../",DE[j],"/",comparison[i],"/report_data/"),
                               pattern = "MAplot_", full.names = T), pattern="Filt", value = T, invert = T),
                               pattern="edgeR", value = T, invert = T), pattern=".png", value=T)

        output<-c(output,cat("##### ",analysis_type[j],"\n"))
        if(length(volcano.files)>=1){
          for(k in 1:length(volcano.files)){
            output<-c(output,cat("<div align='center'>","\n"))
            output<-c(output,cat("<figure><img src=",volcano.files[k]," width='80%'/>","\n"))
            output<-c(output,cat("<figcaption>Volcano plot (DESeq2 results with independent filtering on). Maximum of 20 most DE genes (by adj.p-value) are named.</figcaption></figure>","\n"))
            output<-c(output,cat("<figure><img src=",ma.files[k]," width='80%'/>","\n"))
            output<-c(output,cat("<figcaption>MA plot (DESeq2 results with independent filtering on). Maximum of 20 most DE genes (by adj.p-value) are named.</figcaption></figure>","\n"))
            output<-c(output,cat("</div>","\n\n"))
          }
        }
      }
      output<-c(output,cat("#### {-}","\n\n"))
    }
  }
  return(output)
}

no_null<-volcano.ma.plots(comparison, analysis_type, DE)

```

### {-}

### TOP DE genes {.tabset}

<a name="heatmap-link"> </a>

```{r de-top-de, echo=FALSE, results="asis", dev="svg"}

top.de.plots<-function(comparison=comparison, analysis_type = analysis_type, DE = DE){
  output<-cat("#### ",comparison[1]," {.tabset}","\n")
  for(j in 1:length(DE)){
    top_de.files <- list.files(path=paste0("../",DE[j],"/",comparison[1],"/report_data/"),
                               pattern ="heatmap_selected_orderBaseMeanCluster.png", full.names = T)

    output<-c(output,cat("##### ",analysis_type[j],"\n"))
    if(length(top_de.files)>0){
      if(length(top_de.files)>=1){
        for(k in 1:length(top_de.files)){
          output<-c(output,cat("<div align='center'>","\n"))
          output<-c(output,cat("<figure><img src=",top_de.files[k]," width='80%'/>","\n"))
          output<-c(output,cat("<figcaption>Heatmap of maximum top 20 differentially expressed genes (DESeq2 results with independent filtering, adj.p-value < 0.05, logFC >= +/-1).</figcaption></figure>","\n"))
          output<-c(output,cat("</div>","\n\n"))
        }
      }
    }else{
      output<-c(output,cat("<div align='center'>No DE gene were found from DESeq2 results with independent filtering, adj.p-value < 0.05, logFC >= +/-1.</div>","\n\n"))
    }
  }
  output<-c(output,cat("#### {-}","\n\n"))
  if(length(comparison)>1){
    for(i in 2:length(comparison)){
      output<-c(output,cat("#### ",comparison[i],"\n"))
      for(j in 1:length(DE)){
        top_de.files <- list.files(path=paste0("../",DE[j],"/",comparison[i],"/report_data/"),
                               pattern ="heatmap_selected_orderBaseMeanCluster.png", full.names = T)

        output<-c(output,cat("##### ",analysis_type[j],"\n"))
        if(length(top_de.files)>0){
          if(length(top_de.files)>=1){
            for(k in 1:length(top_de.files)){
              output<-c(output,cat("<div align='center'>","\n"))
              output<-c(output,cat("<figure><img src=",top_de.files[k]," width='80%'/>","\n"))
              output<-c(output,cat("<figcaption>Heatmap of maximum top 20 differentially expressed genes (DESeq2 results with independent filtering, adj.p-value < 0.05, logFC >= +/-1).</figcaption></figure>","\n"))
              output<-c(output,cat("</div>","\n\n"))
            }
          }
        }else{
          output<-c(output,cat("<div align='center'>No DE gene were found from DESeq2 results with independent filtering, adj.p-value < 0.05, logFC >= +/-1.</div>","\n\n"))
        }
      }
      output<-c(output,cat("#### {-}","\n\n"))
    }
  }
  return(output)
}

no_null<-top.de.plots(comparison, analysis_type, DE)

```

### {-}

## Used statistics and selection of differentially expressed genes

### Log2FC and adjusted p-value
- Differences between the conditions are expressed in **log2FC** (log2 of fold-change)
    - This is calculated by comparing average expression one condition vs the other and then the log2 transformation
    - This makes the results symmetric around 0 and it’s easier to understand
    - For example: -1 is a 2-fold decrease of the expression, +1 is a 2-fold increase of the expression.
    - Please note it always depends on the “direction” of the comparison - if you are not sure just compare normalized counts of one gene to see from which “direction” the log2FC was calculated.
- Calculation of DE genes consists of a very high number of comparisons (thousands of genes = thousands of comparisons)
  - For this reason, we need to correct raw p-values for false discovery rate which emerges from the number of comparisons
  - This results in **adjusted p-values** (adj.pval, adj. p-values, adj. pval)
    - In case you want to use some filtering or selection based on the statistical evidence you should ALWAYS USE adjusted p-values and never raw p-values
    - Raw p-values can be used only in very special cases and always require a discussion with bioinformatician or statistician

## Note on selecting of differentially expressed genes (DEG)
- Selection of differentially expressed genes always has to be primarily based on the biological background of the experiment and the hypothesis
- A lot of people select DEG based on a combination of cut-off values
- This might be tricky as no predefined cut-off values exist and it depends on the experiment itself, on the amount of false-positive results you are willing to accept and on the minimum level of changes if any
- Commonly used statistical values, such as logFC and adj.p-value, should help you to confirm the hypothesis, results or the observations and not lead the discovery itself
- If you decide to go for some cut-off values, do not blindly select only genes above the thresholds!
  - For example, the frequently used cut-off value of adj.p-value 0.05 at which you will reject the hypothesis the gene is not expressed the same: one gene will have adj.p-value 0.0499 which would pass this cut-off whereas the second gene will have adj.p-value of 0.0501 and would not pass the cut-off.  The difference between the genes is negligible and still, the first gene would and the other gene would not be accepted if a strict cut-off value would be set.
  - Another “issue” with adj.p-value is when the groups we are comparing are heterogeneous (for example clinical samples). In this case, adj.p-value are generally much higher.  In this situation, we should strongly focus on biological effect and hypothesis and use statistics to either confirm the observation or to function for prioritization of the results
  - The similar thing applies to logFC
  - In the case of logFC, we also have to consider the effect of the expression of individual genes. For example, the frequently used cut-off value of 1 (2x fold-change): A gene with expression 10 in one group and 5 in other group results in logFC 1 and would pass the cut-off. The overall expression of the gene is negligible and most likely the change doesn’t have any biological effect. Another gene has an expression of 10000 in one group and 5001 in another group. This gene would not pass the cut-off value but most likely the change will have some kind of biological effect.
  - Sometimes small logFC might be more important than high logFC and the same applies to adj.p-value.
- We should always choose the genes based on the overall properties of the gene and the comparison between conditions

## Output files
- Results are organized by compared conditions
  - The compared conditions are always stated in the name of the folder
  - All the results in the corresponding folder are based on the currently compared conditions but in some of the cases other samples and conditions are added to the visualization/summaries as well
  - For example: **cond1_vs_cond2** compares cond1 to cond2. In the DE results then - positive log2FC signalizes more expression in cond1 (or less in cond2) and negative log2FC signalizes less expression in cond1 (or more in cond2).
- Main output files are **DESeq2.tsv**, **DESeq2_noIndFilt.tsv**, and **edgeR.tsv**
- All three main results contain several columns:
  - **first column (no name)** - Ensembl gene id
  - **baseMean** - an average expression of genes from samples from compared conditions
  - **log2FoldChange** - log2FC of the gene expression difference. The difference is calculated by comparing average expression of samples of one condition with the other samples from the other condition
  - **stat and lfcSE** (in DESeq2); LR and tgw.Disp (in edgeR) - results of the statistical test performed by the tool and variation/dispersion of the gene
  - **pvalue** - a raw p-value of the comparison
  - **padj** - multiple testing correction (Benjamini-Hochberg correction) p-value of the comparison. In case you are comparing and analyzing RNA-Seq use this as the evaluation of the statistical significance of the comparison
  - **gene_name** - common gene name
  - **gene_biotype** - biotype of the gene
  - **_normCounts** - normalized gene expression for each sample (not only the samples in the current comparison)
  - **_rawCounts** - raw read counts for each sample (not only the samples in the current comparison)
- The full description is given below

- Additional visualizations and/or a different combination of visualization is available upon request after discussion

## General/common outputs
- **xxx** in the name of some pdf files in the description below represents compared conditions
- **background.txt** – list of genes that were expressed in your samples (=gene was expressed in at least one of the samples). The first column is Ensembl gene ID, second is common gene name.
- **norm_counts.xlsx** - DESeq2 normalized counts (~expression) for all genes and all samples. Can be used for visualization of the data.
  - **norm_counts.tsv** - the same information as in norm_counts.xlsx but in a text form.
- **all_sig_genes_normCounts.pdf** – significantly DEG (here, “default cut-off” adj.p-value 0.05 and logFC 1 is considered) expression visualization. Selection of DE genes is based on the particular comparison but all conditions/samples are plotted. This is based on DESeq2 results.
- **counts_barplot.pdf** - visualization of used (raw) read counts per sample
- **DESeq2.tsv** – main results from differential gene expression by DESeq2. Description of the columns is given above. tsv is a tab-separated source file for the xlsx.
- **DESeq2_noIndFilt.tsv** – results from differential gene expression without independent gene filtering (see Independent filtering and Cooks cut-off in DESeq2 manual). tsv is a tab-separated source file for the xlsx.
- **DESeq2_de_genes_check.txt** and **DESeq2_de_genes_check_noIndFilt.txt** – basic summary of differential expression. “Default” adj.p-value of 0.05 and logFC of 1 are used. The upper part of the table considers only adj.p-value cut-off value, the lower part considers adj.p-value and logFC. This servers only for a  demonstration of the possible effect, not as a final result
- **DESeq2_design_control.txt** - a control file for used sample design
- **edgeR.tsv** – main results from differential gene expression by edgeR. tsv is a tab-separated source file for the xlsx.
- **edgeR_de_genes_check.txt** - same as in case of DESeq2 - “quick and dirty” check of the effect to get a general idea about the differences.
- **heatmap_selected_orderBaseMean.pdf** – heatmap of maximum top 20 most differentially expressed genes (based on adj. p-value) ordered by an average expression. Blue means low expression, red means high expression. The maximum top 20 genes are selected based on the compared groups but all samples are visualized. This is based on DESeq2 results.
- **heatmap_selected_orderBaseMeanCluster.pdf** – heatmap of maximum top 20 most differentially expressed genes (based on adj. P-value, same as above) clustered by rows and columns. Blue means low expression, red means high expression. This is based on DESeq2 results.
- **heatmaps_samples.pdf** - heatmap visualization of sample clustering based on gene expression. Several normalizations are applied but the first one usually looks the best.
- **MAplot_xxx_vs_xxx_ggpubr.pdf** - MA plots for the gene expression. Maximum top 20 most DEG (by adj.p-value) are named. This is based on DESeq2 results.
- **MAplot_xxx_vs_xxx_noIndFilt_ggpubr.pdf** -  the same as above but without independent filtering.
- **MDS_plot.pdf** - MDS-based visualization of sample clustering by expression
- **overlap_DESeq2_edgeR_de.tsv** and **overlap_DESeq2_edgeR_venn.pdf** – overlap between DE genes between DESeq2 and edgeR calculation. In default, genes with adj. p-value <0.05 and logFC +/- 1 are included. Columns DESeq2 and edgeR contain values TRUE or FALSE and this represents whether the resulting gene was included in the results by an individual tool.
- **pre_post_norm_counts.pdf** - visualization of used raw (top figure) and normalized (bottom) read counts per sample
- **sample_to_sample_PCA.pdf** - PCA-based visualization of sample clustering by expression. The first figure shows first two PCA components, the second shows all combinations of first three components (~3D look)
- **volcanoplot_xxx_vs_xxx_ggplot2.pdf** – volcano plot of the results from DESeq2. Maximum top 20 most DEG (based on adj.p-value) are depicted. This is based on DESeq2.
- **volcanoplot_xxx_vs_xxx_noIndFilt_ggplot2.pdf** - same as above but without independent filtering.

- Please note the differences between MA and Volcano plots - different X and Y axes giving you a different view on the results.

- Alignments can be visualized in genome browsers such as [IGV](http://software.broadinstitute.org/software/igv/), [Tablet](https://ics.hutton.ac.uk/tablet/) or [Savant](http://www.genomesavant.com/p/savant/index)
  - For more details please read the manual or contact your bioinformatician
- If the mapping files were shared through the online storage please download them as soon as possible and let us know so we can delete them

# Output files (alphabetical order)
## Folders
### Raw_fastq
- Provided raw sequenced fastq files

### Alignment
- Provided alignments in bam format

### QC_general
- html file summarizing most of the QC done

### FeatureCounts_expression
- Gene expression raw counts for each sample

### RSEM_expression
- Gene and transcript expression for each sample
- The normalized expressions are summarized in TPM column

#### Files
- .genes.results.tsv - gene expression estimates
- .isoforms.results.tsv - transcript expression estimates

### UCSC_signals
- Alignment signal for UCSC browser
- Two signal “types” per sample are provided:
  - Unique - signal only from uniquely mapped reads
  - UniqueMultiple - signal from both uniquely and multi-mapped reads
- Each set is then split into two:
  - str1 - signal coming from the alignment to the plus strand of DNA
  - str2 - signal coming from the alignment to the minus strand of DNA
- If you have sense/forward specific library, the signal strand corresponds to the strand of the annotated gene (mapping ----> corresponds to the [+] strand annotation)
- If you have antisense/reverse specific library, the signal strand corresponds to the opposite strand gene annotation (mapping <---- corresponds to the [+] strand annotation)

### DE_analysis
- All files related to Differentially expressed genes analysis

## Gene ontology, GSEA and pathway analysis
- This section summarizes possible follow-up analyses/interpretations of the differential expression results
- In the following analyses the input can sometimes be specified as Ensembl ID (usually provided in the results unless noted otherwise), some tools required common gene names (usually provided in the results as well) or Entrez ID (NCBI/RefSeq)
  - This is always specified in the manual of the tool
- GO and/or Pathway analysis can be performed for up-/down-regulated genes as well as for the whole list of de-regulated genes
  - Both of the analyses give a different view of the results
    - Analysis of separate up-/down-regulated genes gives you a direct answer on the change, in particular, GO or Pathway and the “direction” of the regulation
    - Analysis of all de-regulated genes (up-/down-regulated together) gives you a more broad view of the total change
  - Both of the results are helpful but you have to realize what kind of information you can get and what kind of answer they provide

### Gene Ontology
- Input for gene ontology (GO) testing is usually a list of differentially expressed genes
  - You can either use filtering by some cut-off value(s) or select top X genes sorted by adj.p-value/logFC/...
- You can either analyze all DEG or separately down-/up-regulated
  - Please see the section above for more details
- A second input is gene background/universe
  - This is a list of all genes expressed in the comparison
  - This list is used as a “reference” for the statistical evaluation of significantly changed GO groups
- For “common” organisms like human or mouse, a very nice tool is [GOrilla](http://cbl-gorilla.cs.technion.ac.il/) with very nice figures and direct export to Excel
  - It also contains links to [REViGO](http://revigo.irb.hr/) which can help you to summarize the GO groups into more general categories
- To simply browse GO categories you can use [QuickGO](http://www.ebi.ac.uk/QuickGO/) or [Ontology Lookup Service](http://www.ebi.ac.uk/ols/index)
- Another option to filter down GO categories is [AmiGO2](http://amigo.geneontology.org/amigo/dd_browse).
- If, for whatever reason, you don't have gene ontology annotations but just sequences of your genes you can still get GO analysis. [Blast2GO](https://www.blast2go.com/) is a nice service combining BLAST similarity search with GO annotation to produce GO analysis. There is a free and paid version where the free version gives you basic annotations and have some pretty visualizations. A tutorial is for example here 	https://www.youtube.com/watch?v=GqSqS_izlYg&t=335s.
- Other tools include [g:Profiler](https://biit.cs.ut.ee/gprofiler/) and many more

### Pathway analysis
- Input data are very similar to GO (mentioned above)
- [PANTHER](http://www.pantherdb.org ) and [Reactome](http://www.reactome.org/) provide quite nice analysis for the Pathway analysis and exploration.
  - PANTHER recently started to include GO testing as well so it became a multi-purpose tool
- [KEGG](http://www.genome.jp/kegg/kegg2.html) is another commonly used tools for pathway analysis but it is not that easy to interpret the data unless you know which pathways should be involved

### Gene Set  Enrichment
- Input data to Gene Set Enrichment are a bit different than in previous cases
- You do NOT subsample your results but you take a whole list of gene expression results and sort it according to specified criteria (logFC, adj.p-value, ...)
  - In the case of logFC, you have the most positively changed genes on the top and the most negatively changed genes at the bottom and non-changed genes are in the middle but they are still in the SAME list
  - The enrichment then compares different parts of the list and looks for patterns or similarities
- One of the most used is probably [GSEA](http://software.broadinstitute.org/gsea/index.jsp)
  - It’s a standalone tool which takes some time to learn but provides reasonable results
- [GOrilla](http://cbl-gorilla.cs.technion.ac.il/) also offers gene enrichment analysis
- Another option is to use [DAVID](https://david.ncifcrf.gov/home.jsp) which is also a multipurpose tool but I do not recommend it too much since the interpretation of the results might be difficult and very subjective. But it can still be used if there is no other option or you find it easy to work with.

### Protein-protein interactions
- [HIPPIE](http://cbdm-01.zdv.uni-mainz.de/~mschaefer/hippie/index.php) provides reliable and meaningful human protein-protein interaction networks. It is suitable more for gene-by-gene exploration.
- [STRING](https://string-db.org/cgi/input.pl?UserId=4hzU6jHtBui6&sessionId=fokvQzUPEo8M&input_page_show_search=off) is a database of known and predicted protein-protein interactions supported by SIB, CPR - NNF and EMBL. This includes physical, functional as well as predicted interactions.
- [BioGRID](https://thebiogrid.org/) is an interaction repository with data compiled through comprehensive curation efforts. Contains interactions extracted from publications for major model organisms

### Multipurpose tools and other
- There are other tools/approaches to help with the secondary analysis
- [Enrichr](http://amp.pharm.mssm.edu/Enrichr/) is nice and simple to run the tool to identify enriched pathways, different gene summaries, and many others. It provides many various plots and tables
- [GeneMANIA](http://genemania.org/) visualizes genes and their interaction, co-expression as well as Gene Ontology, etc. It is suitable more for gene-by-gene exploration.
- [ConsensusPathDB-human](http://cpdb.molgen.mpg.de/) integrates several different approaches including pathway analysis
- [BioCyc Database Collection](https://biocyc.org/) is a collection of 9387 Pathway/Genome Databases (PGDBs), plus software tools for understanding their data.
- [KEGG database](http://www.genome.jp/kegg/kegg2.html) is a database resource that integrates genomic, chemical and systemic functional information. In particular, gene catalogs from completely sequenced genomes are linked to higher-level systemic functions of the cell, the organism, and the ecosystem. KEGG accepts common gene names and NCBI gene/transcript ID and UniProt ID. For the analysis, you can use http://www.genome.jp/kegg/tool/map_pathway2.html or http://www.genome.jp/kegg/tool/map_pathway1.html. KEGG looks for genes in your list and tries to highlight the pathway where selected genes have some kind of association.
- [Venny](http://bioinfogp.cnb.csic.es/tools/venny/) is a nice tool for a simple visualization of overlaps between up to three sets of data.

### R/Bioconductor
- If you know how to use **R** you can check [**clusterProfiler**](https://bioconductor.org/packages/release/bioc/html/clusterProfiler.html) which provides many different analyses types and has very nice manual and tutorials
- [**topGO**](http://bioconductor.org/packages/release/bioc/html/topGO.html) is another R package which offers both gene ontology and gene set enrichment analysis
- [**ReactomePA**](https://bioconductor.org/packages/release/bioc/html/ReactomePA.html) allows for analysis of pathways with a slightly different source than KEGG
- To add GO categories (and other interesting information) to your list of genes, you can try [**biomaRt**](https://bioconductor.org/packages/release/bioc/html/biomaRt.html) which can directly load the Ensembl database

